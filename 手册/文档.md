Julia让包开发者和用户通过内建的文档系统（始于Julia v0.4）能很容易给函数、类型和别的对象添加文档。

基本语法很简单：任何正好出现在对象（函数、宏、类型、实例）前一行的字符串将被解释为该对象的文档（叫做“文档字符串”）。
注意，在文档字符串和被注解的对象之间不能插入空行或注释。
看个基本例子：
```
"华安无耻地玷污秋香。"
fuck(boy::AbstractString, girl::AbstractString) = ...
```
文档解释为[Markdown](https://en.wikipedia.org/wiki/Markdown)（如本文格式），因此可用缩进和“代码护栏”来界定文本和代码例程。
技术上，任何对象可关联别的对象为元数据；Markdown碰巧是默认的，但是可以构建别的字符串宏并照样能传递给`@doc`宏。

这儿有个更复杂的例子，仍然用Markdown：
````
"""
    fuck(boy, girl)

男娃和女娃做羞羞事。

# 例子
```julia-repl
julia> fuck("huaan", "qiuxiang")
"ない，のどを突き破る。"
```
"""
function fuck(boy, girl) ...
````
如上述例程中，推荐在写文档时遵循某些简单的惯例：

- 总是在一开始显式函数的签名，带四个空格的缩进，这样可以打印为Julia代码。

    可以跟Julia代码中的签名相同（如`mean(x::AbstractArray)`），或者简化形式。  
    可选参数应当展示默认值（即`f(x, y=1)`），若可能的化，遵循Julia的实际语法。  
    可选参数，没有默认值的应当放入中括号内，如`f(x[, y])`和`f(x[, y[, z]])`。  
    一个备选方案是使用若干行：一个没有可选参数，其余的带可选参数。  
    该方案可能用于给给定函数的相关方法添加文档。  
    当一个函数接受许多关键字参数，仅在签名中包含`<keyword arguments>`占位符，如`f(; <keyword argument>)`，并且在`# Arguments`下面给出完整参数表（看下面的第四点）。

- 包括唯一单行语句的函数动作或在简化的签名块之后表达啥对象的描述。如果需要，在第二段提供更详细的，隔一个空行（像Git注释短长又像HTTP请求头体的分隔）。

    给函数添加文档时，单行语句应当采用“命令”形式（干这个并返回那个），而不是第三人称（不要写“返回长度云云”)。  
    应当以句号结束。  
    如果函数的意义不容易总结，分割为独立的组成部分是有益的（尽管这不应该作为每个单行情况的绝对要求）。

- 不要重复自己。

    因为函数名是签名给定的，因此没必要以“函数`fuck`……”开始：直击要害（开门见山）。  
    类似地，如果签名指定了参数的类型，在描述中再次提及是多余的。

- 仅在必要的时候提供参数列表。

    针对简单函数，直接在函数目的的描述中提及参数角色通常是清晰的。  
    别处的参数列表可能只是重复已经提供的信息。  
    然而，有很多参数（特别是关键字参数）的复杂函数，提供参数列表是个好主意。  
    在这种情况下，在函数一般描述之后插入参数列表，在`# Arguments`头之下，每个参数前导一个`-`“子弹”。  
    参数列表应当提到参数类型和参数默认值（若有）：
    ```
    """
    #上文
    # Arguments
    - `n::Integer`: 要计算的元素个数。
    - `dim::Integer=1`: 要遍历的对象的维度，默认值是一。
    #下文
    """
    ```

- 提供相关函数的提示。

    有些时候，函数有相关的函数。  
    为了提升可发现性，请在`See also:`段落提供简短的相关函数列表。
    ```
    See also: [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref)
    ```

- 在`# Examples`部分包含任何代码历程。

    例程应当，任何时候可能的话，写为文档字符串。  
    文档字符串是防护代码块（见【代码块】），以` ```jldoctest`开始且包含任意个`julia>`提示符，和输出及期望的输出一起模仿JuliaREPL。

    举个例子，下述文档字符串中，一个变量`a`被定义，期望的结果，像在JuliaREPL中打印的那样，随后出现：
    ````
    """
    # 若干暖文。

    # Examples
    ```jldoctest
    julia> a = [1 2; 3 4]
    2×2 Array{Int64,2}:
    1  2
    3  4
    ```
    """
    ````
    **警告**：应当在文本字符串中避免调用`rand`以及别的RNG（随机数字发生器：Random Number Generator）相关的函数，因为这些函数输出在不同的Julia会话中不固定。  
    如果就是像显式某些随机数发生器相关的函数，一个选项是显式构造并用自己的`MersenneTwister`（或别的伪随机数发生器）为种子并传递给被添加文档字符串的函数。  
    操作系统字长（`Int32`或`Int64`），路径分隔符（`/`或`\`）也会影响某些文档字符串的再现性。  
    注意文档字符串中的空格有意义的！举个例子，和数组优雅打印不重合的文档字符串会失败。

    然后可以运行`make -C doc doctest=true`来执行Julia手册和API文档中的全部文档字符串，将确保例程工作正常。

    为了标识输出结果是节选的（去尾），应当在检查要停止的行写上`[...]`。  
    这对隐藏栈回溯（包含非永久的Julia代码行引用）有用，当文档字符串显示异常，例如：
    ````
    ```jldoctest
    julia> div(1, 0)
    ERROR: DivideError: integer division error
    [...]
    ```
    ````
    不可验证的例程应当写入以` ```julia`开头的保护代码块中，这样可以在生成的文档中正确高亮。

    **提示**：任何可能的地方，例程应当自包含且可运行，这样读者能够在不必须包含任何依赖的情况下验证之。

- 用反引号（backtick）识别代码和等式。

    Julia标识符和代码节选（excerpt）应当总是出现在反引号`` ` ``之间以高亮。  
    以LaTex语法的等式可插入在双反引号``` `` ```之间。  
    宁可采用Unicode字符，而不用其LaTex转义序列，也就是说要``` ``α = 1`` ```、不要``` ``\\alpha = 1`` ```。

- 置开始和结束的`"""`独立成行。

    那就是，这么写：
    ```
    """
    # 哦

    # 哦哦
    """
    f(x, y) = ...
    # 已被一刀捅死
    ```
    而不要写成：
    ```
    """啊

    噢嗯"""
    f(x, y) = ...
    # 还是走吧
    ```
    上一种让文档字符串的开始和结束更清晰。

- 遵守用于周围代码的行长度。

    文档字符串用和编码一样的编辑。  
    因此适用相同约定。  
    推荐92个字符后添加一个换行符。

- 提供信息以让定制类型在`# Implementation`部分中实现函数。

    这些实现细节是给开发者的，而不是给普通用户的，阐述诸如那些函数应当被覆盖、那些函数自动采用合适的后手，和函数行为的主要描述区分开是好的做法。

# 访问文档
