Julia让包开发者和用户通过内建的文档系统（始于Julia v0.4）能很容易给函数、类型和别的对象添加文档。

基本语法很简单：任何正好出现在对象（函数、宏、类型、实例）前一行的字符串将被解释为该对象的文档（叫做“文档字符串”）。
注意，在文档字符串和被注解的对象之间不能插入空行或注释。
看个基本例子：
```
"华安无耻地玷污秋香。"
fuck(boy::AbstractString, girl::AbstractString) = ...
```
文档解释为[Markdown](https://en.wikipedia.org/wiki/Markdown)（如本文格式），因此可用缩进和“代码护栏”来界定文本和代码例程。
技术上，任何对象可关联别的对象为元数据；Markdown碰巧是默认的，但是可以构建别的字符串宏并照样能传递给`@doc`宏。

这儿有个更复杂的例子，仍然用Markdown：
````
"""
    fuck(boy, girl)

男娃和女娃做羞羞事。

# 例子
```julia-repl
julia> fuck("huaan", "qiuxiang")
"ない，のどを突き破る。"
```
"""
function fuck(boy, girl) ...
````
如上述例程中，推荐在写文档时遵循某些简单的惯例：

- 总是在一开始显式函数的签名，带四个空格的缩进，这样可以打印为Julia代码。

    可以跟Julia代码中的签名相同（如`mean(x::AbstractArray)`），或者简化形式。  
    可选参数应当展示默认值（即`f(x, y=1)`），若可能的化，遵循Julia的实际语法。  
    可选参数，没有默认值的应当放入中括号内，如`f(x[, y])`和`f(x[, y[, z]])`。  
    一个备选方案是使用若干行：一个没有可选参数，其余的带可选参数。  
    该方案可能用于给给定函数的相关方法添加文档。  
    当一个函数接受许多关键字参数，仅在签名中包含`<keyword arguments>`占位符，如`f(; <keyword argument>)`，并且在`# Arguments`下面给出完整参数表（看下面的第四点）。

- 包括唯一单行语句的函数动作或在简化的签名块之后表达啥对象的描述。如果需要，在第二段提供更详细的，隔一个空行（像Git注释短长又像HTTP请求头体的分隔）。

    给函数添加文档时，单行语句应当采用“命令”形式（干这个并返回那个），而不是第三人称（不要写“返回长度云云”)。  
    应当以句号结束。  
    如果函数的意义不容易总结，分割为独立的组成部分是有益的（尽管这不应该作为每个单行情况的绝对要求）。

- 不要重复自己。

    因为函数名是签名给定的，因此没必要以“函数`fuck`……”开始：直击要害（开门见山）。  
    类似地，如果签名指定了参数的类型，在描述中再次提及是多余的。

- 仅在必要的时候提供参数列表。

    针对简单函数，直接在函数目的的描述中提及参数角色通常是清晰的。  
    别处的参数列表可能只是重复已经提供的信息。  
    然而，有很多参数（特别是关键字参数）的复杂函数，提供参数列表是个好主意。  
    在这种情况下，在函数一般描述之后插入参数列表，在`# Arguments`头之下，每个参数前导一个`-`“子弹”。  
    参数列表应当提到参数类型和参数默认值（若有）：
    ```
    """
    #上文
    # Arguments
    - `n::Integer`: 要计算的元素个数。
    - `dim::Integer=1`: 要遍历的对象的维度，默认值是一。
    #下文
    """
    ```

- 提供相关函数的提示。

    有些时候，函数有相关的函数。  
    为了提升可发现性，请在`See also:`段落提供简短的相关函数列表。
    ```
    See also: [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref)
    ```

- 在`# Examples`部分包含任何代码历程。

    例程应当，任何时候可能的话，写为文档字符串。  
    文档字符串是防护代码块（见【代码块】），以` ```jldoctest`开始且包含任意个`julia>`提示符，和输出及期望的输出一起模仿JuliaREPL。

    举个例子，下述文档字符串中，一个变量`a`被定义，期望的结果，像在JuliaREPL中打印的那样，随后出现：
    ````
    """
    # 若干暖文。

    # Examples
    ```jldoctest
    julia> a = [1 2; 3 4]
    2×2 Array{Int64,2}:
    1  2
    3  4
    ```
    """
    ````
    **警告**：应当在文本字符串中避免调用`rand`以及别的RNG（随机数字发生器：Random Number Generator）相关的函数，因为这些函数输出在不同的Julia会话中不固定。  
    如果就是像显式某些随机数发生器相关的函数，一个选项是显式构造并用自己的`MersenneTwister`（或别的伪随机数发生器）为种子并传递给被添加文档字符串的函数。  
    操作系统字长（`Int32`或`Int64`），路径分隔符（`/`或`\`）也会影响某些文档字符串的再现性。  
    注意文档字符串中的空格有意义的！举个例子，和数组优雅打印不重合的文档字符串会失败。

    然后可以运行`make -C doc doctest=true`来执行Julia手册和API文档中的全部文档字符串，将确保例程工作正常。

    为了标识输出结果是节选的（去尾），应当在检查要停止的行写上`[...]`。  
    这对隐藏栈回溯（包含非永久的Julia代码行引用）有用，当文档字符串显示异常，例如：
    ````
    ```jldoctest
    julia> div(1, 0)
    ERROR: DivideError: integer division error
    [...]
    ```
    ````
    不可验证的例程应当写入以` ```julia`开头的保护代码块中，这样可以在生成的文档中正确高亮。

    **提示**：任何可能的地方，例程应当自包含且可运行，这样读者能够在不必须包含任何依赖的情况下验证之。

- 用反引号（backtick）识别代码和等式。

    Julia标识符和代码节选（excerpt）应当总是出现在反引号`` ` ``之间以高亮。  
    以LaTex语法的等式可插入在双反引号``` `` ```之间。  
    宁可采用Unicode字符，而不用其LaTex转义序列，也就是说要``` ``α = 1`` ```、不要``` ``\\alpha = 1`` ```。

- 置开始和结束的`"""`独立成行。

    那就是，这么写：
    ```
    """
    # 哦

    # 哦哦
    """
    f(x, y) = ...
    # 已被一刀捅死
    ```
    而不要写成：
    ```
    """啊

    噢嗯"""
    f(x, y) = ...
    # 还是走吧
    ```
    上一种让文档字符串的开始和结束更清晰。

- 遵守用于周围代码的行长度。

    文档字符串用和编码一样的编辑。  
    因此适用相同约定。  
    推荐92个字符后添加一个换行符。

- 提供信息以让定制类型在`# Implementation`部分中实现函数。

    这些实现细节是给开发者的，而不是给普通用户的，阐述诸如那些函数应当被覆盖、那些函数自动采用合适的后手，和函数行为的主要描述区分开是好的做法。

# 访问文档
在JuliaREPL或[IJulia](https://github.com/JuliaLang/IJulia.jl)中可以通过`?`后跟随函数名或宏名、接着`Enter`键来访问文档字符串。
例如：
```
?cos
?@time
?r""
```
会分别带出相关函数、宏或字符串宏的文档字符串。
在[Juno](http://junolab.org/)中用`Ctrl-J`、`Ctrl+D`带出鼠标下对象的文档字符串。

# 函数和方法

在Julia中，函数可能有许多实现，也叫方法。
虽然一般函数有一个目的是好的实践，Julia允许给方法分别添加文档，如果需要的话。
一般地，只有大多数一般方法应当添加文档，或函数本身（也就是说以`function bar end`创建的没有任何方法的对象）。
只有当具体方法的行为和更一般的方法不同时方可添加文档。
在任何情况下，都不能重复在别处已经提供的信息。
例如：
```
"""
    *(x, y, z...)

乘法操作符。
`x * y * z *...`以因子参数调用该函数。
也就是`*(x, y, z...)`。
"""
function *(x, y, z...)
    # ... [独立的实现体] ...
end

"""
    *(x::AbstractString, y::AbstractString, z::AbstractString...)

当应用到多个字符串，将这些字符串黏结起来。
"""
function *(x::AbstractString, y::AbstractString, z::AbstractString...)
    # ... [这里插入秘诀] ...
end

help?> *
search: * .*

  *(x, y, z...)

  乘法操作符。
  x * y * z *...以多个因子参数调用该函数。
  也就是*(x,y,z...)。

  *(x::AbstractString, y::AbstractString, z::AbstractString...)

  当应用到多个字符串，将这些字符串粘结起来。
```
当为一般函数检索文档字符串时，每个方法的元数据以`catdoc`函数粘结，当然也可以在定制类型中被覆盖。

# 高级用发

这个`@doc`宏将第一个参数和第二个参数关联到每个模块的叫做`META`的字典中。
默认地，文档字符串期望被写成Markdown，并且`doc"..."`字符串宏简单创建表达Markdown内容的对象。
未来很可能实现诸如允许创建相关图像或链接路径等更多高级东西。

为使书写文档字符串更简单，解析器特别对待宏名`@doc`：如果调用`@doc`带一个参数，单个换行后出现另一个表达式，则该额外表达式作为该宏的参数。
因此下述语法解析为两个参数调用`@doc`：
```
@doc raw"""
...
"""
f(x) = x
```
这让将任何对象（上述是`raw`字符串）用作文档字符串变得可信手拈来。

当用于文档检索时，宏`@doc`（或等价的`doc`函数）将搜索所有`META`字典，找出和给定对象对应的元数据并返回之。
返回的对象（例如某种Markdown内容）将默认聪明地显示自身。
这种设计也让以编程方式应用文档系统变得简单；举个例子，复用函数不同版本的文档：
```
@doc "..." fuck!
@doc (@doc fuck!) fuck!
```
或者用在Julia的元编程函数：
```
for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))
    @eval begin
        $f(a,b) = $op(a,b)
    end
end
@doc "`add(a,b)`即把`a`和`b`相加起来" add
@doc "`subtract(a,b)`即从`a`中减去`b`" subtract
```
写在非顶层块的文档，例如`begin`、`if`、`for`和`let`也加入文档系统，就像块一样被计算。
例如：
```
if condition()
    "..."
    f(x) = x
end
```
将添加文档给`f(x)`，当`condition()`是`true`。
注意即使`f(x)`在块的末尾走出作用域，文档仍被保留。

# 动态文档

有些时候，一个类型实例的恰当的文档取决于该实例的字段值，而不止是类型本身。
在这些情况下，可以给`Docs.getdoc`添加针对定制类型的方法，每个实例为基础返回文档。
例如：
```
struct MyType
    value::String
end

Docs.getdoc(t::MyType) = "值是$(t.value)的类型MyType的文档。"

x = MyType("x")
y = MyType("y")
```
`?x`将显示“值是x的类型MyType的文档”；`?y`将显示“值是y的类型MyType的文档”。

# 语法指南

Julia语法的整体概览。

在下述例子中`"..."`用来演示任意文档字符串。

`doc"..."`应当仅用在文档字符串包含`$`或`\`字符时，不应当被Julia解析，诸如LaTex语法或包含篡改的Julia源代码例程。

## 函数和方法

```
"..."
function f end

"..."
f
```
给函数`f`添加文档`"..."`。
第一个版本是首选的语法，然而，两种写法等价。
```
"..."
f(x) = x

"..."
function f(x)
  x
end

"..."
f(x)
```
给`f(::Any)`添加文档`"..."`。
```
"..."
f(x, y=1) = x + y
```
给两个方法添加文档，名为`f(::Any)`和`f(::Any, ::Any)`。

## 宏

```
"..."
macro m(x) end
```
给`@m(::Any)`宏定义添加文档。
```
"..."
:(@m)
```
给名为`@m`的宏添加文档。

## 类型

```
"..."
abstract type Tx end

"..."
mutable struct Rx
  ...
end

"..."
struct UART
  ...
end
```
给`Tx`、`Rx`和`UART`添加文档“...”。
```
"..."
struct Port
  "t"
  t
  "r"
  r
end
```
给类型`Port`添加文档“...”，给字段`Port.t`添加文档“t”，给字段`Port.r`添加文档“r”。
也适用于`mutable struct`类型。

## 模块

```
"..."
module M end

module M

"..."
M

end
```
给模块`M`添加文档“...”。
给模块添加文档，上述语法优先，然而，两者等价。
```
"..."
baremodule M
  ...
end

baremodule M

import Base: @doc

"..."
f(x) = x

end
```
给`baremodule`添加文档，上述表达式自动导入`@doc`到当前模块中。
这些导入必须手动完成，当模块表达式未加文档时。
**空`baremodule`不可加文档**。

## 全局变量

```
"..."
const a = 1

"..."
b = 2

"..."
global c = 3
```
给各个`Binding`，即`a`、`b`、`c`添加文档“...”。

`Binding`用来再`Module`中保存特定`Symbol`的引用，而不用保存所引用的值本身。

**注意**：当定义一个`const`时，仅用于定义另一个定义的别名，举个例子，`Base`中的函数`div`及其别名`÷`，不要给别名添加文档，而要给实际的函数添加文档。

如果别名被添加文档，并且不是真正的定义，则文档系统（`?`模式）搜索真正定义的时候，不会返回附加在别名上的文档。

举个例子，应该这么写：
```
"..."
f(x) = x + 1
const alias = f
```
而不是：
```
f(x) = x + 1
"..."
const alias = f
```

```
"..."
sym
```
给`sym`关联的值添加文档。
用户最好在`sym`定义处添加文档。

## 多个对象

```
"..."
a, b
```
给`a`和`b`，应当都是可添加文档的表达式，添加文档。
该语法等价于：
```
"..."
a

"..."
b
```
可以这种方式同时给任意个表达式添加文档。
当两个函数相关时，这种语法会显得特别有用，例如不可变和可变版本的`f`和`f!`。

## 宏生成的代码

```
"..."
#m expression
```
