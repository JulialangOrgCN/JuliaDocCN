Julia给全部原始数值类型提供了完整的基本算术和位操作集，也提供了可移植的、高效的标准数学函数综合集。

# 算术操作

下面列出Julia全部原始数值类型都支持的[算术操作](https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations)。

|表达式|名称|描述|
|:---:|:---:|:---:|
|+x|一元加|恒等算子（the identity operation）|
|-x|一元减|将数值映射为加的逆运算|
|x + y|二元加|执行加法|
|x - y|二元减|执行减法|
|x * y|乘|执行乘法|
|x / y|除|执行除法|
|x ÷ y|整除|相当于把x/y的结果截取整数部分|
|x \ y|反转除|等价于y/x|
|x ^ y|幂|将x自乘y次|
|x % y|求余|等价于rem(x,y)|

还有Bool类型的取反操作。

|表达式|名称|描述|
|:---:|:---:|:---:|
|!x|否|就是true和false的相互逆操作|

**插一句：**
```
# 尽管Bool假数值上等于整型0
julia> false == 0
true

# 但是Bool类型的取反操作只能应用在该类型
julia> !0
ERROR: MethodError: no method matching !(::Int64)
Closest candidates are:
  !(::Missing) at missing.jl:79
  !(::Bool) at bool.jl:35
  !(::Function) at operators.jl:853
Stacktrace:
 [1] top-level scope at none:0
```

Julia的类型【[转换和提升系统](./转换和提升.md "Conversion and Promotion")】使得混合类型参数算术操作自然自动地进行。

体会下面简单示例：
```
julia> 1 + 2 + 3
6

julia> 1 - 2
-1

julia> 3*2/12
0.5
```
按照惯例，猪吏偏好将单目运算符更贴近被操作标识符，比如：
```
julia> x = 9527
9527

# 一元减（-）紧挨x
# 二元加（+）两侧有空格
# 明确表示先给x取负然后和1314相加
julia> -x + 1314
-8213
```

# 位操作

下面列出的[位操作](https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators)，Julia的全部原始整型类型都支持。

|表达式|名称|
|:---:|:---:|
|~x|按位取反|
|x & y|按位与|
|x | y|按位或|
|x ⊻ y|按位异或|
|x >>> y|[逻辑](https://en.wikipedia.org/wiki/Logical_shift)右移|
|x >> y|[算术](https://en.wikipedia.org/wiki/Arithmetic_shift)右移|
|x << y|逻辑或算术左移（**若溢出则按逻辑左移**）|

体会下面简单示例：
```
julia> ~123
-124

julia> 0b1010 & 0b0101
0x00

julia> 0b1010 | 0b0101
0x0f

julia> 0b1010 ⊻ 0b0101
0x0f

julia> 0b1010 ⊻ 0b1010
0x00

julia> xor(0b1010, 0b0101)
0x0f

julia> xor(0b1010, 0b1010)
0x00

julia> x = UInt8(64)
0x40

julia> bitstring(x)
"01000000"

julia> bitstring(x >>> 2)
"00010000"

julia> bitstring(x >> 2)
"00010000"

julia> bitstring(x << 1)
"10000000"

julia> bitstring(x << 2)
"00000000"

julia> y = Int8(-64)
-64

julia> bitstring(y)
"11000000"

julia> bitstring(y >>> 2)
"00110000"

julia> bitstring(y >> 2)
"11110000"

julia> bitstring(y << 1)
"10000000"

# 负数做逻辑或算术左移可能成为正数
# 这和Python的实现不同
julia> bitstring(y << 2)
"00000000"

julia> y << 2
0
```

# 更新操作

每个二元算术操作和位操作都有“更新版本”操作，即将操作结果返回给左边的被操作标识符；
各自对应的更新操作就是在二元算术操作或位操作之后紧跟“=”，举栗子：
```
julia> x = 1
1

julia> x += 3
4

# 位操作交换两个变量的值
julia> x = 0b10101111
0xaf

julia> y = 0b11110101
0xf5

julia> x ⊻= y
0x5a

julia> y ⊻= x
0xaf

julia> x ⊻= y
0xf5
```

全部二元算术操作和位操作的更新版本操作是：【`+= -= *= /= \= ÷= %= ^= &= |= ⊻= >>>= >>= <<=`】。

要注意的是：**更新操作重新绑定左侧被操作标识符，可能导致变量类型变化**。
```
julia> x = 0x01
0x01

julia> typeof(x)
UInt8

julia> x *= 2.0
2.0

julia> typeof(x)
Float64
```

# 向量化点操作

全部二元操作和单目操作，都有对应的点操作。
*不磨叽，直接上示例代码。*
```
julia> [0,1,2,3,4] .^ 2
5-element Array{Int64,1}:
  0
  1
  4
  9
 16

julia> .√[0,1,2,3,4]
5-element Array{Float64,1}:
 0.0
 1.0
 1.4142135623730951
 1.7320508075688772
 2.0

julia> .! [true,false,false,true,true]
5-element BitArray{1}:
 false
  true
  true
 false
 false

julia> .- [true,false,false,true,true]
5-element Array{Int64,1}:
 -1
  0
  0
 -1
 -1

julia> .+ [true,false,false,true,true]
5-element Array{Int64,1}:
 1
 0
 0
 1
 1
```

更具体地讲（more specifically），“a .^ b”解析为【[点调用幂](./函数.md "Functions")】，这会执行【[广播操作](./多维数组.md "Multi-dimensional Arrays")】：能够结合数组和标量，数组的维度相同（执行矩阵元素操作）、数组的形状不同（行列向量联合生成一个矩阵）。

此外，像所有向量化“点调用”一样，这些点操作是融合的：例如计算数组A的“2 .* A.^2 .+ sin.(A)”（或等价的“@. 2A^2 + sin(A)——运用‘@.’宏”），将在A上执行单循环、计算A的每个元素“2a^2 + sin(a)”。特别是嵌套点调用（f.(g.(x))）是混合的，且临近的二元操作如“x .+ 3 .* x.^2”等价于嵌套点调用“(+).(xm (*).(3, (^).(x, 2)))”。

而且，点更新操作，如“a .+ b”解析为“a .= a .+ b”，这里的“.=”混合内联（in-place）赋值操作，具体参考【[函数](./函数.md "Functions")】。

注意，点操作语法也适用于群众自定义的操作，举个栗子，如果秀才定义“⊗(A,B) = kron(A,B)”为【克罗内克积（[kron](../标准库/线性代数.md "Linear Algebra")）】的便捷中缀（别名），则有“[A,B] .⊗ [C,D]”等于“[A⊗C, B⊗D]”，而不需要额外代码。

点操作结合数值字面则会引起歧义。
例如“1.+x”就搞不清是“1. + x”还是“1 .+ x”，因此不允许这种语法，必须在操作符两侧根据实际意图留下空白。

```
julia> x = 2
2

julia> 1 .+ x
3

julia> 1. + x
3.0
```

# 数值比较

Julia的所有原始数值类型都支持标准比较操作：

|操作|名称|
|:---:|:---:|
|==|等于|
|!=或≠|不等于|
|<|小于|
|<=或≤|小于等于|
|>|大于|
|>=或≥|大于等于|

体会下面简单示例：
```
julia> 9527 == 1314
false

julia> 9527 != 1314
true

julia> 9527 ≠ 1314
true

julia> 9527 > 1314
true

julia> 9527 ≥ 1314
true

julia> 9527 < 1314
false

julia> 9527 ≤ 1314
false

julia> 1.0 == 1
true

julia> +0 == -0
true
```

整型数值比较按照习惯姿势（比较比特）。

浮点数值比较根据[IEEE 754](https://en.wikipedia.org/wiki/IEEE_754-2008)标准:

- 有限数字按惯例排序；
- 正零等于负零，并不是正零就比负零大；
- Inf和自身相等，大于除NaN之外的任意数字；
- -Inf和自身相等，小于除NaN之外的任意数字；
- NaN不等于、不小于、不大于任何数字，包括本身！

最后一点说点可能令人惊奇的，但没意义的东西：
```
julia> NaN == NaN
false

# NaN不等于本身
julia> NaN != NaN
true

julia> NaN < NaN
false

julia> NaN > NaN
false
```

数组中出现NaN会引起特殊的头痛：
```
julia> [0 1 NaN] == [0 1 NaN]
false
```

对于特殊数值，Julia提供了别的函数来测试，在hash键比较中很有用：

|函数|测试|
|:---:|:---:|
|isequal(x, y)|x和y相等否|
|isfinite(x)|x有限否|
|ifinf(x)|x无限否|
|isnan(x)|x非数字否|

- isequal认为NaN和自身相等

```
julia> isequal(NaN, NaN)
true

julia> isequal([0 1 NaN], [0 1 NaN])
true

julia> isequal(NaN, NaN32)
true
```

- isequal还可以区分正负零

```
julia> isequal(+0.0, -0.0)
false

julia> +0.0 == -0.0
true
```

有符号整型、无符号整型、浮点类型的混合类型比较必须留心（tricky）。
Julia小心呵护以保证正确运算。

别的类型，isequal默认调用“==”操作，因此群众想自定义相等操作，只需要添加“==”方法。
如果秀才自定义自己的相等函数，或许应该同时自定义相应hash方法以确保isequal(x, y)暗含“hash(x) == hash(y)”。

# 链式比较

