Julia拥有提升数学操作参数为普通类型的系统，在各种别的文中曾被提到，包括【[整型数字和浮点型数字](./整型数字和浮点型数字.md "Integers and Floating-Point Numbers")】、【[算术操作符和基本函数](./算术操作符和基本函数.md "Mathematical Operations and Elementary Functions")】、【[类型](./类型.md "Types")】和【[方法](./方法.md "Methods")】。
本文中，解释提升系统如何工作，以及如何扩展之、应用到新的类型，不止内建的数学操作。
传统中，编程语言根据算术参数提升分为两大阵营：

- 内建算术类型和操作自动提升

    大多数编程语言中，内建数值类型，以中缀语法用于算术操作的被操作数时，如`+`、`-`、`*`、`/`等，自动提升参与操作的数值为共同类型产出期望的结果。C/Java/Perl/Python，举几个例子来说（to name a few），`1+1.5`求和的全部正确计算即浮点值`2.5`，尽管被操作数之一是整数。这类系统便捷且被细心设计得足以让程序员通常无感（超薄劲爽）：在编写这种些表达式得时候几乎没有程序员有意识地思考提升地发生，但编译器和解释器必须在做加法之前执行转换，因为整数和浮点数不能囫囵（as-is）相加。此种转换的复杂规则是这些编程语言规格和实现不可避免的部分。

- 无自动提升

    这一帮包括Ada/ML（变态严格的静态类型编程语言）。这些编程语言中，每个转换都必须由程序员明确指定。因此，例如表达式`1+1.5`会是编译错误（Ada/ML）。相反，必须写为`real(1)+1.5`。到处显式转换如此不方便，然而，Ada有某种程度的自动转换：整数字面值自动提升为期望的整数类型，浮点字面值近似提升为恰当的浮点数值类型。

某种意义上（in a sense），Julia落入（fall into）“无自动提升”范畴：算术操作只是拥有特殊语法的函数，函数的参数绝不会被自动转换。
然而，可以观察到，应用算术操作到各种混合参数类型只是多态多重载的极端情况——Julia的重载和类型系统特别适合处理的某些东西。
算术操作的“自动”提升简单暴露为特殊应用：Julia与生俱来的预定义捕捉算术操作的全部重载规则，当不存在某些被操作数类型组合的匹配实现时被调用。
这些捕捉全部规则首先以用户可定义的提升规则提升所有被操作数为共同类型，然后调用结果值成问题的指定实现，这时候被操作数类型是一致的。
用户自定义类型可简单参与改提升系统，定义转换方法（转成别的类型或从别的类型转化）即可，提供一小撮（a handful of）提升规则，定义当混合别的类型的的类型提升为什么类型。

# 转换

获取某一类型`T`的值的标准方法是调用该类型的构造方法，`T(o)`。
然而，存在便于将值从一个类习转换为另一个类型、而无须程序员显式要求的情况。
一个例子就是给数组赋值：如果`A`是`Vector{Float64}`，表达式`A[1]=2`应当自动转换`2`，从`Int`到`Float64`，并将结果存入数组。
这可通过`convert`函数完成。

这个`convert`函数通常带两个参数：前一个是类型对象，后一个是要被转为前述类型的值。
返回值是转换为给定类型的实例。
理解该函数最简单的方式是看实践：
```
julia> huaan = 9527
9527

julia> typeof(huaan)
Int64

julia> convert(UInt16, huaan)
0x2537

julia> typeof(ans)
UInt16

julia> convert(AbstractFloat, huaan)
9527.0

julia> whoredom = Any[0 1 2; 250 9527 1314]
2×3 Array{Any,2}:
   0     1     2
 250  9527  1314

julia> convert(Array{Float64}, whoredom)
2×3 Array{Float64,2}:
   0.0     1.0     2.0
 250.0  9527.0  1314.0
```
不总是可能被成功转换，这些失败的情况抛出`MethodError`表明`convert`函数不知道如何执行请求的转换：
```
julia> convert(AbstractFloat, "cto")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
Closest candidates are:
  convert(::Type{T<:Number}, ::T<:Number) where T<:Number at number.jl:6
  convert(::Type{T<:Number}, ::Number) where T<:Number at number.jl:7
  convert(::Type{T<:Number}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250
  ...
Stacktrace:
 [1] top-level scope at none:0

# 注意
julia> convert(AbstractFloat, "0.0")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
Closest candidates are:
  convert(::Type{T<:Number}, ::T<:Number) where T<:Number at number.jl:6
  convert(::Type{T<:Number}, ::Number) where T<:Number at number.jl:7
  convert(::Type{T<:Number}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250
  ...
Stacktrace:
 [1] top-level scope at none:0
```
某些编程语言考虑解析字符串为数字或格式化数字为字符串纳入转换（很多动态编程语言甚至自动执行转换），然而，Julia不会这样做：即使某些字符串可被解析为数值，大多字符串并非有效的数字（字面），仅非常有限的字符串是。
因此Julia中专用的`parse`函数必须用来自行该操作，使其更光明磊落。

## 何时`convert`被调用

下述编程语言概念调用`convert`函数：

- 给数组赋值，将值转换为数组元素类型；
- 给对象字段赋值，将值转换为字段声明的类型；
- 用`new`构造对象，将字段值转换为声明的字段类型；
- 给声明类型（如`local o::T`）赋值，将值转换为该声明的类型；
- 带声明返回值类型的函数转换返回值为该声明的类型；
- 传递值给`ccall`转换值为对应的参数类型。

## 转换对比构造方法

注意`convert(T, o)`的行为貌似（appear to be）差不多和`T(o)`一样。
的确，通常确实如此。
然而，