Julia，像大多数技术计算编程语言一样，提供一流的数组实现。
大多数技术计算编程语言着重其数组实现是以别的容器为代价的。
Julia不给数组搞特殊化。
数组库几乎全部由Julia自身实现，从编译器获得它的性能，正如任何别的Julia代码。
同样地，可以通过继承`AbstractArray`定义客户数组类型。
查阅【[抽象数组接口](./接口.md "Interfaces-AbstarctArrays")】获取有关实现定制数组类型地更多细节。

数组就是保存在一个多维网格的一组对象。
在绝大多数常规情况下，数组会包含`Any`类型的对象。
针对大多数计算目的，数组应当包含更具体类型的对象，如`Float64`和`Int32`。

一般地，不同于许多别的技术计算编程语言，Julia不期望为了性能将程序以向量化风格编写。
Julia的编译器使用类型推理并生成标量数组索引优化的代码，允许程序以便捷且可读的风格编写，不必牺牲性能，偶尔还占用较少的内存。

在Julia中，所有函数的参数【[按共享传递](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing)】。
某些技术计算编程语言是【按值传递】，因为这放置被调用者意外修改调用者中的值，这很难避免不需要的数组拷贝。
按照惯例，名称以`!`结尾的函数表明将变更或销毁一个或多个参数的值（比较如`sort`和`sort!`）。
被调用者必须明确拷贝确保不修改不打算变更的输入。
很多非可变函数通过在输入的拷贝上调用同名尾加`!`的函数实现，并返回该拷贝。

# 基本函数

|函数|说明|
|:---|:---|
|`eltype(A)`|`A`包含元素的类型|
|`length(A)`|`A`中元素的个数|
|`ndims(A)`|`A`的维度|
|`size(A)`|包含`A`的各个维度的大小|
|`size(A,n)`|沿着第`n`维的`A`的大小|
|`axes(A)`|包含`A`的有效索引的元组|
|`axes(A,n)`|沿着第`n`维的有效索引的范围表达|
|`eachindex(A)`|访问`A`每个位置的高效迭代器|
|`stride(A,k)`|沿着第`k`维的步幅（毗邻元素间的线性索引距离）|
|`strides(A)`|每个维度的步幅元组|

# 构造方法和初始化函数

数组有许多构造方法和初始化函数。
下列函数，带`dims...`参数，可以是单个维度大小元组，也可以当作可变参数传递一系列维度大小；并且多数函数还接受第一个参数`T`指明数组元素的类型，若缺省，则默认`Float64`。

|函数|说明|
|:---|:---|
|`Array{T}(undef, dims...)`|未初始化的密集`Array`|
|`zeros(T, dims...)`|全是零的`Array`|
|`ones(T, dims...)`|全是一的`Array`|
|`trues(dims...)`|全是`true`的`BitArray`|
|`falses(dims...)`|全是`false`的`BitArray`|
|`reshape(A, dims...)`|和`A`数据相同、纬度不同的数组。|
|`copy(A)`|拷贝`A`|
|`deepcopy(A)`|递归拷贝`A`的元素|
|`similar(A, T, dims...)`|和`A`类型相同的未初始化的数组，但有着指定元素类型和维度。第二个参数和第三个参数是可选的，若缺省，则默认为`A`的类型和维度。|
|`reinterpret(T, A)`|和`A`的二进制数据相同，但元素类型是`T`的数组。|
|`rand(T, dims...)`|随机值填充的`Array`，在`[0,1)`区间满足[独立同分布](https://baike.baidu.com/item/独立同分布 "independently and identically distributed")和[均匀分布](https://baike.baidu.com/item/均匀分布 "uniformly distributed")。|
|`randn(T, dims...)`|随机值填充的`Array`，满足[标准正态分布](https://baike.baidu.com/item/标准正态分布 "standard normally distributed")。|
|`Matrix{T}(I, m, n)`|`m`行`n`列的单元矩阵。|
|`range(start; length, stop, step=1)`|从`start`到`stop`的线性空间元素集，其中`start`必给，`length`和`stop`可选其一。|
|`fill!(A, x)`|用`x`填充数组`A`。|
|`fill(x, dims...)`|用`x`填充的、维度是`dims`每个元素的数组。|

语法`[A, B, C, ...]`构造了一维数组（也叫做向量）。
如果所有的元组具有相同“提升类型”，则用`convert`转为该共同类型。

看几个示例：

```
multidims = zeros(Int8, 2, 3)
tupdims = zeros(Int8, (2, 3))
defaulttype = zeros((2, 3))

println(multidims)
println(tupdims)
println(defaulttype)

# Int8[0 0 0; 0 0 0]
# Int8[0 0 0; 0 0 0]
# [0.0 0.0 0.0; 0.0 0.0 0.0]
```

# 串联

数组可用下列函数构造和串联：

|函数|描述|
|:---|:---|
|`cat(A...; dims=k)`|沿着维度`k`串联数组|
|`vcat(A...)`|是`cat(A...; dims=1)`的简写|
|`hcat(A...)`|是`cat(A...; dims=2)`的简写|

标量传入这些函数，按包含一个元素的一维数组处理。
例如：

```
julia> vcat([9527,1314],250)
3-element Array{Int64,1}:
 9527
 1314
  250

julia> hcat([1314 9527],250)
1×3 Array{Int64,2}:
 1314  9527  250
```

串联函数还有常用的特殊语法：

|表达式|调用|
|:---|:---|
|[A; B; C; ...]|`vcat`|
|[A B C ...]|`hcat`|
|[A B; C D; ...]|`hvcat`|

其中`hvcat`先横向（空格分隔）再纵向（分号分隔）地串联。
例如：

```
julia> [[1, 2]; [3, 4]]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia> [[1 2]; [3 4]]
2×2 Array{Int64,2}:
 1  2
 3  4
```

# 指定元素类型的数组初始化器

可用`T[A, B, C, ...]`在构造数组的同时指定元素的类型。
这将构建一个一维的、元素类型是`T`的数组，初始化包含元素`A`、`B`、`C`等等。
举个例子，`Any[x, y, z]`构造异种数组，可以包含任意类型的元素。

【串联语法】可相似地前缀一个类型，指定结果的元素类型。

```
julia> [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia> Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4
```

# 解析（comprehension）

解析提供了构造数组的通用的、强大的方法。
解析的语法和设置构造注解的数学语句相似。

`A = [ F(x,y,...) for x=rx, y=ry, ...]`

该形式的含义是：`F(x,y,...)`用变量`x`、`y`等计算得出，而`x`、`y`从给定的一组值的列表中获取。
这个值列表可以用任何可迭代的对象指定，通常是区间，如`1:n`、`2:(n-1)`等，或直截了当的数组，如`[95.27， 13.14， 2.5]`。
结果是`N`维密度数组，维度是可变区间`rx`、`ry`等等的维度的串联，并且每个`F(x,y,...)`计算返回一个标量。

下列例程计算一个一维网格（矩阵）的每个元素及其前后相邻元素的加权平均值（数字滤波器）：

```
julia> x = rand(8)
8-element Array{Float64,1}:
 0.7081596354089565
 0.18612391607590983
 0.34344826134631967
 0.6027627527974453
 0.7481391896138416
 0.520190957225642
 0.5747980150875391
 0.1845319115430457

julia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.35596393222677397
 0.3689457978914986
 0.574278239138763
 0.6548080223126926
 0.5908297797881662
 0.4635797247359415
```

结果数组的类型取决于被计算的元素类型。
为了明确控制类型，可为解析表达式前缀一个类型。
举个例子，要求结果是单精度，可以这么写：

`Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]`

# 生成器表达式

解析表达式也可以不带包裹在最外侧的中括号，产生一个人称“生成器”的对象。
该对象可以迭代地产生需要的值，而不是上来就开辟存储空间并保存整个数组，高级用法见【迭代】。
举个例子，下述表达式对一系列值做累加，不用开辟（完整）内存：

```
julia> sum(1/n^2 for n=1:1000)
1.6439345666815615
```

当参数列表中有多维来编写一个生成器表达式，圆括号必不可少地来隔离生成器及后续参数：

```
julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification
```

在`for`之后全部逗号分隔地表达式被解释为区间。
添加圆括号来表示`map`的第三个参数：

```
julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1:4;])
4-element Array{Tuple{Float64,Int64},1}:
 (0.5, 1)
 (0.3333333333333333, 2)
 (0.3333333333333333, 3)
 (0.25, 4)

julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1:4; 5:8])
4-element Array{Tuple{Float64,Int64},1}:
 (0.5, 1)
 (0.3333333333333333, 2)
 (0.3333333333333333, 3)
 (0.25, 4)

julia> map(tuple, (1/(i+j) for i=1:2, j=1:2))
2×2 Array{Tuple{Float64},2}:
 (0.5,)       (0.333333,)
 (0.333333,)  (0.25,)

julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 4; 5 8])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 4)
 (0.333333, 5)  (0.25, 8)
```

生成器通过内部函数实现。
正如Julia别处所用的部函数，来自闭包范围的变量可在内部函数中被捕捉到。
举个例子，`sum(p[i] - q[i] for i=1:n)`从闭包范围捕捉`p`、`q`和`n`三个变量。
被捕捉的变量将提出性能挑战，详见【[性能窍门](./性能窍门.md)】。

生成器中的范围和解析表达式可基于多个`for`的前置范围：

```
julia> [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)
```

该例的结果总是一维的。

生成的值可通过`if`来过滤：

```
julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)
```

# 索引（泥潭——专业领域的数学和语法深度耦合）

索引某个N维数组`A`的一般语法是：`X = A[I_1, I_2, ..., I_n]`。

其中每个`I_k`是标量整数、整数数组或任何【支持索引的对象】。
包含冒号（[Colon](../基础/数组.md "Base: Arrays-Colon")）来选择全部维度的索引，`a:c`或`a:b:c`选择连续地或带步幅地分段区间，布尔型数组来选中对应位置是`true`地索引。

如果所有索引全是标量，结果`X`是来自`A`数组地一维向量。
否则，`X`的维数是所有被选中的索引的维度总和。

如果所有索引全是矢量，举个例子，当`X`的形状可能是`(length(I_1), length(I_2), ..., length(I_n))`，`X`的`(i_1, i_2, ..., i_n)`位置包含值是`A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]`。

例程：

```
julia> A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> A[1, 2, 1, 1] # 标量索引
3

julia> A[[1,2], [1], [1,2], [1]] # 矢量索引
2×1×2×1 Array{Int64,4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia> A[[1,2], [1], [1,2], 1] # 标矢混合索引
2×1×2 Array{Int64,3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6
```

**后两个结果的尺寸是不一样的！**

*=====陷入噩梦=====*

如果`I_1`改为二维矩阵，则`X`变成`n+1`维数组，形状是`(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))`。
**矩阵增加了一个维度。**

```
julia> A[[1 2; 1 2], 1, 2, 1]
2×2 Array{Int64,2}:
 5  6
 5  6
```

位置`(i_1, i_2, i_3, ..., i_{n+1})`包含`A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]`位置的值。
所有用标量索引的维度被抛弃。
例如`A[2, I, 3]`的结果是尺寸为`size(I)`的数组，其元素通过`A[2, I[i], 3]`构成。

*=====逃离噩梦=====*

关键字`end`作为特殊的语法，可在索引中括号中表示每个维度最后一个索引，用来检测被索引的最内存数组的尺寸。
不带`end`关键字的索引语法和调用`getindex`等价。

```
X = getindex(A, I_1, I_2, ..., I_n)
```

例程：

```
julia> X = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> X[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia> X[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1
```

形如`n:n-1`的空区间有时候用来索引介于`n-1`和`n`之间的插入索引位置。
例如[searchsorted](../基础/排序及其相关函数.md "Base: Sort-and-Related-Functions")用此便捷方式来表示在某个已排序的数组中某个不存在的值的插入点。

```
julia> a = [2, 5, 7, 9]
4-element Array{Int64,1}:
 2
 5
 7
 9

julia> searchsorted(a, 4)
2:1
```

# 赋值
