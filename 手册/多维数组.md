Julia，像大多数技术计算编程语言一样，提供一流的数组实现。
大多数技术计算编程语言着重其数组实现是以别的容器为代价的。
Julia不给数组搞特殊化。
数组库几乎全部由Julia自身实现，从编译器获得它的性能，正如任何别的Julia代码。
同样地，可以通过继承`AbstractArray`定义客户数组类型。
查阅【[抽象数组接口](./接口.md "Interfaces-AbstarctArrays")】获取有关实现定制数组类型地更多细节。

数组就是保存在一个多维网格的一组对象。
在绝大多数常规情况下，数组会包含`Any`类型的对象。
针对大多数计算目的，数组应当包含更具体类型的对象，如`Float64`和`Int32`。

一般地，不同于许多别的技术计算编程语言，Julia不期望为了性能将程序以向量化风格编写。
Julia的编译器使用类型推理并生成标量数组索引优化的代码，允许程序以便捷且可读的风格编写，不必牺牲性能，偶尔还占用较少的内存。

在Julia中，所有函数的参数【[按共享传递](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing)】。
某些技术计算编程语言是【按值传递】，因为这放置被调用者意外修改调用者中的值，这很难避免不需要的数组拷贝。
按照惯例，名称以`!`结尾的函数表明将变更或销毁一个或多个参数的值（比较如`sort`和`sort!`）。
被调用者必须明确拷贝确保不修改不打算变更的输入。
很多非可变函数通过在输入的拷贝上调用同名尾加`!`的函数实现，并返回该拷贝。

# 基本函数

|函数|说明|
|:---|:---|
|`eltype(A)`|`A`包含元素的类型|
|`length(A)`|`A`中元素的个数|
|`ndims(A)`|`A`的维度|
|`size(A)`|包含`A`的各个维度的大小|
|`size(A,n)`|沿着第`n`维的`A`的大小|
|`axes(A)`|包含`A`的有效索引的元组|
|`axes(A,n)`|沿着第`n`维的有效索引的范围表达|
|`eachindex(A)`|访问`A`每个位置的高效迭代器|
|`stride(A,k)`|沿着第`k`维的步幅（毗邻元素间的线性索引距离）|
|`strides(A)`|每个维度的步幅元组|

# 构造方法和初始化
