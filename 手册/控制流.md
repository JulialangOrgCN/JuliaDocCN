Julia提供各种各样的控制流概念：

- 复合表达式：`begin`和`(;)`。
- 条件计算：`if-elseif-else`和`?:`（三元操作符）。
- 短路计算：`&&`、`||`和链式比较。
- 重复计算（循环）：`while`和`for`。
- 异常处理：`try-catch-finally`、`error`和`throw`。
- 任务（即协程）：`yieldto`。

前五个控制流机制对高级编程语言来说是标配的。
协程并非标配：提供非本地控制流，让临时挂起的计算切换成为可能。
这是强大的概念：Julia中异常处理和多任务合作都是基于协程实现的。
日藏编程不需要直接适用任务，但特定问题可通过任务更简单地得到解决。

# 复合表达式

有些时候，单个表达式中按顺序计算若干子表达式、返回最后一个表达式的值作为结果是便捷的。
Julia中有两种设计来完成：`begin`块和`(;)`链。
这两种复合表达式构建的值都是最后一个子表达式的。这儿展示一个`begin`块的例子：
```
julia> z = begin
         x = 9527
         y = 1314
         x + y
       end
10841
```
由于这些表达式相当小且简单，很容易放置在单行，正式`(;)`链语法随手拈来：
```
julia> z = (x = 9527; y = 1314; x + y)
10841
```
【[函数](./函数.md "Functions")】简明单行函数定义形式兼备该语法特别有用。
尽管这是典型的，但是并未要求`begin`块是多行或`(;)`链是单行的。
```
julia> begin x = "huaan"; y = "qiuxiang"; x * " " * y end
"huaan qiuxiang"

julia> (x = "huaan";
        y = "qiuxiang";
        x * " " * y)
"huaan qiuxiang"
```

# 条件计算

条件计算允许部分代码被计算或不被计算，取决于一个布尔型表达式的值。
下面演示`if-elseif-else`条件语法的脉络（骨骼）：
```
julia> function toy(x, y)
         if x < y
           println("x is less than y")
         elseif x > y
           println("x is more than y")
         else
           println("x is equal to y")
         end
       end
toy (generic function with 1 method)

julia> toy(9527, 1314)
x is more than y

julia> toy(1314, 9527)
x is less than y

julia> toy(0, 0)
x is equal to y
```
如果条件表达式`x < y`是`true`（成立），则相应的代码块被计算；否则条件表达式`x > y`被计算且如果是`true`（成立），则相应的代码块被计算；若前两个条件都不成立，则`else`代码块被执行。

其中`elseif`和`else`块是可选的，并且许多`elseif`块渴望被用到。
在`if-elseif-else`概念中条件表达式挨个儿被计算，直到有一个成立（`true`），对应的代码块被执行后，其余条件表达式及其对应的代码块都不再被计算。

注意`if`代码块有“漏洞”，就是说条件表达式并不引进本地范围，这意味着在`if`子句中定义新的变量，之后也可用，即使先前并未定义该变量。因此可以这么定义`toy`函数：
```
julia> function toy(x, y)
         if x < y
           relation = "less than"
         elseif x == y
           relation = "equal to"
         else
           relation = "more than"
         end
         println("x is ", relation, " y")
       end
toy (generic function with 1 method)

julia> toy(0, 0)
x is equal to y

julia> toy(9527, 1314)
x is more than y

julia> toy(1314, 9527)
x is less than y
```
其中`relation`变量在`if`块中定义，却在外部使用。
然而，当基于该特性时，要确保所有可能代码路径都为该变量定义了值。
下面改写的`toy`函数将导致运行时错误：
```
julia> function toy(x, y)
         if x < y
           relation = "less than"
         elseif x == y
           relation = "equal to"
         else
           "more than"
         end
         println("x is ", relation, " y")
       end
toy (generic function with 1 method)

julia> toy(0, 0)
x is equal to y

julia> toy(1314, 9527)
x is less than y

julia> toy(9527, 1314)
ERROR: UndefVarError: relation not defined
Stacktrace:
 [1] toy(::Int64, ::Int64) at .\REPL[15]:9
 [2] top-level scope at none:0
```
而且`if`块还有返回值，这让来自别的编程语言的群众似乎不直观。该返回值就是简单地返回所选分支最后一条被计算的声明。
因此：
```
julia> huaan = 9527
9527

julia> if huaan > 1314
         "positive"
       else
         "negative"
       end
"positive"
```
注意Julia中非常短的条件声明（一行）频繁采用短路计算，正如后边概述的。

不同于C、MATLAB、Perl、Python和Ruby，但和Java、少数几个强类型编程语言相似，如果条件表达式是除`true`和`false`之外任何东西，都报错。
```
julia> if "qiuxiang"
         println("bitch")
       end
ERROR: TypeError: non-boolean (String) used in boolean context
Stacktrace:
 [1] top-level scope at none:0
```
错误提示说条件是错误的`String`类型，而非要求的`Bool`类型。

所谓的三元操作符`?:`和`if-elseif-else`紧密相关，仅用于需要单个表达式值间的条件选择，和更长代码块的条件执行形成鲜明对比。因大多数编程语言中仅用三个被操作数的操作符而得名：`condition ? one(true): another(false)`。

在`?`之前的表达式`condition`是条件表达式，如果条件表达式是真，三元操作符计算表达式`one`（`:`之前的），否则计算`another`（`:`之后的）。
牢记`?`和`:`前后的空白是必须的，像`condition?one?another`不是合法的三元表达式（但`?`和`:`之后接受新行）。

理解这种行为最简单的方式就是看例子。在之前的示例中，三个分支共同调用`println`函数：唯一真正的选项就是所打印的字面字符串。用三元操作符改写会更简明。为了清晰（for the sake of clarify），让咱一起先尝试个“双路”版本：
```
julia> x = 9527; y = 1314
1314

julia> println(x < y ? "less than" : "more than")
more than

julia> x, y = y, x
(1314, 9527)

julia> println(x < y ? "less than" : "more than")
less than
```
如果表达式`x < y`是真，则整个三元操作符表达式计算字符串`"less than"`，否则是`"more than"`。
原始的“三路”例程需要链接多个三元操作符一起来：
```
julia> toy(x, y) = println(x < y ? "less than" : x > y ? "more than" : "equal to")
toy (generic function with 1 method)

julia> toy(9527, 1314)
more than

julia> toy(1314, 9527)
less than

julia> toy(0, 0)
equal to
```
为帮助（理解）链接，操作符从右到左关联。

值得注意的是，像`if-elseif-else`一样，在`:`之前或之后的表达式，仅在条件表达式是真或是假是相应地被计算。
```
julia> pseudo(what) = (print(what); what)
pseudo (generic function with 1 method)

julia> true ? pseudo("yes") : pseudo("no")
yes"yes"

julia> false ? pseudo("yes") : pseudo("no")
no"no"
```

# 短路计算

短路计算和条件计算非常相似。这种行为在大多数命令式编程语言中也能找到有`&&`和`||`布尔操作符：一系列由这些操作符连接的布尔表达式，只计算足够判定整个链最终布尔值的最少数成员布尔表达式。摊开讲，意思就是：

- 在`one && another`表达式中，仅当表达式`one`是`true`时才计算表达式`another`。
- 在`one || another`表达式中，仅当表达式`one`是`false`时才计算表达式`another`。

原因是`one && another`只要`one`是假则整体必然是假，无论`another`真假；同理`one || another`只要`one`是真则整体必然是真，无论`another`真假。

且（`&&`）和或（`||`）都是从左到右关联，但且优先级高于或。
很同意试出且或的行为：
```
julia> mTrue(x) = (println(x); true)
mTrue (generic function with 1 method)

julia> mFalse(x) = (println(x); false)
mFalse (generic function with 1 method)

julia> mTrue(9527) && mTrue(1314)
9527
1314
true

julia> mTrue(9527) && mFalse(1314)
9527
1314
false

julia> mFalse(9527) && mTrue(1314)
9527
false

julia> mFalse(9527) && mFalse(1314)
9527
false

julia> mTrue(9527) || mTrue(1314)
9527
true

julia> mTrue(9527) || mFalse(1314)
9527
true

julia> mFalse(9527) || mTrue(1314)
9527
1314
true

julia> mFalse(9527) || mFalse(1314)
9527
1314
false
```

可以相同方式简单地试出复合且或操作符的结合性和优先级。

经常拿且或短路计算组成非常短的可选`if`声明。
可以写`<condition> && <statement>`（条件是然后声明）来替代`if <condition> <statement> end`。
同理，可以写`<condition> || <statement>`（条件否然后声明）来替代`if ! <condition> <statement> end`。

举个例子，递归阶乘协程可定义如下：
```
julia> function mFactorial(n::Int)
         n >= 0 || error("n must be non-negative")
         n == 0 && return 1
         n * mFactorial(n-1)
       end
mFactorial (generic function with 1 method)

julia> mFactorial(9)
362880

julia> mFactorial(0)
1

julia> mFactorial(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] error(::String) at .\error.jl:33
 [2] mFactorial(::Int64) at .\REPL[62]:2
 [3] top-level scope at none:0
```

无短路计算的不二操作可通过【[算术操作符和基本函数](./算术操作符和基本函数.md "Mathematical Operations and Elementary Functions")】中介绍的位布尔运算（`&`和`|`）实现。
这些（按位与或）是正常函数，恰好（happen to）支持中缀操作符语法，但总是计算各个参数（表达式）：
```
julia> mFalse(9527) & mTrue(1314)
9527
1314
false

julia> mTrue(9527) & mTrue(1314)
9527
1314
true
```

正如`if`、`elseif`或三元操作符中使用的条件表达式，`&&`或`||`的被操作数必须是布尔类型。
除最后一个条目外，任何地方在条件链中使用非布尔类型值都是错误的：
```
julia> 9527 && true
ERROR: TypeError: non-boolean (Int64) used in boolean context
Stacktrace:
 [1] top-level scope at none:0
```

另一方面，条件链末尾可以使用任何类型的表达式，将根据前一个条件的结果被计算、被返回。
```
julia> true && (9527, 1314)
(9527, 1314)

julia> false || (1314, 9527)
(1314, 9527)
```

# 重复计算（循环）
