Julia的函数是映射一组参数值到返回值的对象（*别的编程语言函数不也是么*）。

Julia的函数不是纯粹数学方程，意思是函数会改变且受程序全局状态的影响。

Julia的函数基本定义语法如下：
```
julia> function fuck(male, female)
         println("$(male) fucks $(female) or $(female) fucks $(male)?")
       end
fuck (generic function with 1 method)
```

有种更简洁的Julia函数定义语法。上述传统函数声明语法演示等价于下述紧凑的“赋值形式”：
```
julia> kiss(male, female) = "$(male) pushes tongue down $(female)'s throat or $(female) pushes tongue down $(male)'s throat?"
kiss (generic function with 1 method)
```
这种赋值形式定义的Julia函数，函数体必须是单条表达式，尽管可以是【[混合表达式](./控制流.md "Control Flow - Compound Expressions")】。
Juia中短小精悍的函数定义如家常便饭。
这种简单函数语法相应地很符合习惯，显著减少输入和视觉干扰。

函数通过常规的圆括号语法调用：
```
# 书接上文
julia> fuck("alice", "bob")
alice fucks bob or bob fucks alice?

julia> kiss("alice", "bob")
"alice pushes tongue down bob's throat or bob pushes tongue down alice's throat?"
```

不带圆括号，表达式`fuck`、`kiss`引用函数对象，可以当作任何值一样传递：
```
julia> coitus = fuck
fuck (generic function with 1 method)

julia> pax = kiss
kiss (generic function with 1 method)
```

函数名像任何变量名一样，是可以用Unicode的：
```
julia> 操(男, 女) = "$(男) 操 $(女) 还是 $(女) 操 $(男)?"
操 (generic function with 1 method)

julia> 亲(男, 女) = "$(男) 把舌头塞进 $(女) 的嘴里还是 $(女) 把舌头塞进 $(男) 的嘴里?"
亲 (generic function with 1 method)

julia> 操("华安", "秋香")
"华安 操 秋香 还是 秋香 操 华安?"

julia> 亲("华安", "秋香")
"华安 把舌头塞进 秋香 的嘴里还是 秋香 把舌头塞进 华安 的嘴里?"
```

# 参数传递德行
Julia函数参数遵循有时称作“共享传递”的约定，这意味着传递到函数的参数值并没有做拷贝，而参数扮演的是新的变量绑定（引用参数值的新地址），所引用的值才是真正传入的东西，在修改可变值（如数组）参数，调用者也会看到。
共享传递在Scheme、Python、Ruby、Perl，大多数Lisp以及别的动态编程语言中很常见。

# `return`

函数的返回值默认是最后一个表达式的计算结果。
在C或别的命令式、函数式编程语言中，关键字`return`导致函数直接返回紧跟的表达式的计算结果。
```
julia> function beat(hero, heroine)
         return "$(hero) versus. $(heroine)"
         println("一山不容二虎——除非一公一母")
       end
beat (generic function with 1 method)
```

由于函数定义可进入交互式会话，对比这些定义很简单：
```
# 书接上文
julia> beat("jack", "rose")
"jack versus. rose"
```

当然，在一个纯线性函数体（如`beat`这样），运用`return`掷到点子上（不得要领），因为表达式`println("一山不容二虎——除非一公一母")`永远不被计算，省略`return`可以把`"$(hero) versus. $(heroine)"`放到最后一条。
结合控制流才是`return`真正的用武之地。
举个[栗子](https://github.com/JulialangOrgCN/howtojulia/blob/master/manual/functions.jl)，计算两条直角边长分别式`a`和`b`的直角三角形的斜边长`c`的函数避免溢出：

![](../插图/Manual-Functions-Hypotenuse-Avoid-Overflow.png "hypotenuse avoid overflow")

上述`hypotenuse`函数有三个可能的返回点，返回结果来自三个不同的表达式，取决于参数`a`和`b`的值。
最后一行的`return`可以省略，因为是最后一个表达式。

还可以在定义函数时用`::`操作符指定返回结果类型。
这将返回值转换成指定的类型。
```
julia> function ages(one, another)::Int8
         return one + another
       end
ages (generic function with 1 method)

# 爱情面前年纪不是问题（问题是钱）
julia> ages(66, 22)
88
```

这样`ages`函数总是返回`Int8`类型值，不论`x`或`y`的类型。
查看【[类型声明](./类型.md "Types - Type Declaratioins")】获取更多返回类型。

# 操作符即函数

猪吏大多数操作符就是特殊语法支持的函数。
*例外是带特殊计算语义如`&&`和`||`的操作符，这些操作符不可作函数是因为【[短路计算](./控制流.md "Control Flow - Short-Circuit Evaluation")】要求操作对象在操作符计算之前不能被计算。*
于是乎，群众可以把参数列表用圆括号包裹起来，把操作符当作任意别的函数那样用：
```
julia> 9527 + 1314 + 250
11091

julia> +(9527,1314,250)
11091
```

中缀形式恰好等价于函数应用形式——事实上前者解析为产生内部函数调用。
这意味着群众可以拿如`+`、`*`等操作符赋值，可以将之传递，就像别的函数值一样：
```
julia> add = +
+ (generic function with 163 methods)

julia> add(9527,1314,250)
11091
```
然而，以`add`命名的加函数（即`+`操作符）不支持中缀注解。
```
julia> 9527 add 1314 add 250
ERROR: syntax: extra token "add" after end of expression
```

# 有特殊名称的操作符

一小撮特殊表达式和调用*无明显名称（non-obvious name）*的函数是一致的。

|表达式|调用的函数|
|:---:|:---:|
|`[A B C ...]`|`hcat`|
|`[A;B;C; ...]`|`vcat`|
|`[A B; C D; ...]`|`hvcat`|
|`A'`|`adjoint`|
|`A[i]`|`getindex`|
|`A[i] = x`|`setindex!`|
|`A.n`|`getproperty`|
|`A.n = x`|`setproperty!`|

# 匿名函数

函数在Julia中式一等对象：可以赋值给变量，并按照标准函数调用语法调用所赋值的变量；可以当作参数；可以作为返回值。

可以创建没有函数名的匿名函数：
```
julia> x -> x^2 + 2x +1
#3 (generic function with 1 method)

julia> function (x)
         x^2 + 2x + 1
       end
#5 (generic function with 1 method)
```
这样就创建了带一个参数`x`返回值是`x^2+2x+1`（`(x+1)^2`）的函数。
注意到表达式结果是“generic function”（通用函数），但是带着*基于连续编号*的编译器产生名。

*TODO: 显然编译器产生名并不连续且不是从一开始。*

匿名函数最主要的应用是将其作为别的函数参数传递。
典型例子是`map`函数，应用函数到数组每个元素并返回包含结果的新数组：
```
julia> map(round, [9.527,95.27,952.7])
3-element Array{Float64,1}:
  10.0
  95.0
 953.0
```
如果一个有效转换（上述例程的四舍五入）的命名函数已经存在，作为第一个参数传递给`map·是没问题的。
然而，经常没有已经备好待用的函数。
这种情况下匿名函数概念允许简单创建无需名称的一次性（single-use）函数对象：
```
julia> map(x -> x^2+2x+1, [1,2,3,4,5,6,7,8,9,0])
10-element Array{Int64,1}:
   4
   9
  16
  25
  36
  49
  64
  81
 100
   1
```

接受多个参数的匿名函数定义：`(x,y,z) -> 3x+4y+5z`。

无参数匿名函数定义：`() -> 'egg'`。
没参数函数的想法似乎有些奇怪，但在“延迟计算”中很有用：将晚些调用的代码封装到一个无参数函数中。

# 元组

Julia中内建的称为“元组”的数据结构和函数参数及返回值密切相关。
一个元组就是能保存任何值得固定长度的容器，但*不能修改（回想共享传递对照Python的元组可知这个结论须做深入理解）*。
元组由逗号和圆括号构成，可以通过索引访问。

```
julia> (9527, "1314")
(9527, "1314")

julia> ans[1]
9527
```

- 一个元素的元组：("the lonely element"`,`)
- 空元组：()

## 命名元组

元组的成员能带可选的名称，成员带名称的元组：
```
julia> (9527, "1314")
(9527, "1314")

julia> ans[1]
9527
```

命名元组和元组非常相似，除了可以通过点操作符访问成员名称所引用的值。

# 多个返回值

Julia通过返回元组模拟返回多个值。
然而，元组可以无须圆括号地构建和解构，这里给出返回多个值、而非返回一个元组的示例。
```
julia> function nameparse(fullname)
         ming, shi, xing = split(fullname, ".")
         ming, shi, xing
       end
nameparse (generic function with 1 method)

julia> nameparse("Adullah.xiucai.Mohamed")
("Adullah", "xiucai", "Mohamed")
```
一旦调用、马上便知返回的是元组。

多个返回值的典型应用就是将每个返回元素抽取到对应变量，Julia支持简单元组解构来简化这一过程：
```
julia> haha, heihei, hehe = nameparse("Adullah.xiucai.Mohamed")
("Adullah", "xiucai", "Mohamed")

julia> haha
"Adullah"

julia> heihei
"xiucai"

julia> hehe
"Mohamed"
```

也可以用`return`显式返回多个值。

# 参数解构

解构特性也适用于函数参数：
```
julia> maxmin(x, y) = (x > y) ? (x, y) : (y, x)
maxmin (generic function with 1 method)

julia> distance((_max, _min)) = _max - _min
distance (generic function with 1 method)

julia> distance(maxmin(9527, 1314))
8213
```
特别要注意`distance`函数参数的一对内部圆括号，没有的话就认为`distance`有两个参数，则上例不能正常执行。

# 不定参数函数


