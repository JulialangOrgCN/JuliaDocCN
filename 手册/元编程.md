在Julia中，Lisp最大的遗产就是支持元编程。
如Lisp一样，Julia用和编程语言本身相同的数据结构表达代码。
由于对象所表现的代码可从编程语言内部创建和操作，程序改变和生成自有代码是可能的。
这允许复杂代码生成，无须额外构建步骤，且允许[抽象语法树](https://en.wikipedia.org/wiki/Abstract_syntax_tree)级别的真Lisp风格宏操作。
相反，预处理宏系统，如C/C++的，视在任何实际解析或解释发生之前执行字面处理和替换的。
因为Julia的全部数据类型和代码由Julia数据结构表达，强大的[反射](https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29)能力可用来像任何别的数据那样探测程序内部及其类型。

# 程序表达

每个Julia程序以字符串入世：
```
julia> program = "9527 + 1314"
"9527 + 1314"
```

**接下来发生了什么？**

下一步是[解析](https://en.wikipedia.org/wiki/Parsing#Computer_languages)每个字符换为叫做表达式的对象，由Julia类型`Expr`表示：
```
julia> xa = Meta.parse(program)
:(9527 + 1314)

julia> typeof(xa)
Expr
```

`Expr`对象包含两部分：

- 一个`Symbol`标识表达式的种类。一个符号就是一个[缓存（interned）字符串](https://en.wikipedia.org/wiki/String_interning)标识符（更多讨论后边说）。

    ```
    julia> xa.head
    :call
    ```

- 表达式参数，可以是符号、别的表达式或字面值。

    ```
    julia> xa.args
    julia> xa.args
    3-element Array{Any,1}:
        :+
    9527
    1314
    ```

表达式也可以直接在[波兰表示法](https://en.wikipedia.org/wiki/Polish_notation)构造：
```
julia> xb = Expr(:call, :+, 9527, 1314)
:(9527 + 1314)
```

上述两中构造表达式（通过解析字符串或直接构造）是等价的。
```
julia> xa == xb
true
```

**这里的关键点是Julia代码内在地表达为编程语言本身可访问的数据结构。**

函数`dump`提供缩进且带注释的`Expr`对象显示：
```
julia> dump(xa)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 9527
    3: Int64 1314

julia> dump(xb)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 9527
    3: Int64 1314
```

`Expr`对象也可能嵌套：
```
julia> xc = Meta.parse("(4 + 4) / 2")
:((4 + 4) / 2)
```

查看表达式的另一种方法是`Meta.show_sexpr`，它显示给定`Expr`的[S表达式](https://en.wikipedia.org/wiki/S-expression)，这看起来个对Lips用户可能非常熟悉。
这里给个展示嵌套`Expr`演示的例子：
```
julia> Meta.show_sexpr(xc)
(:call, :/, (:call, :+, 4, 4), 2)
```

## 符号

字符`:`在Julia中有两种语义目的。
第一种形式创造一个`Symbol`，一个【缓存字符串】用作表达式的一个构件块：
```
julia> :symbola
:symbola

julia> typeof(ans)
Symbol
```

构造函数`Symbol`接受任意个参数并把它的字符串表达连接起来创建一个新的符号：
```
julia> :symbolb == Symbol("symbolb")
true

julia> Symbol("fuck", 9527, "yet")
:fuck9527yet

julia> Symbol(:var, '_', "count")
:var_count
```

在一个表达式的上下文中，符号通常用来表示访问变量；
当一个表达式被计算，一个符号被绑定到该符号的值替代，在合适的【[作用域](./变量的作用域 "Scope of Variables")】。

偶尔，为避免解析时模棱两可，字符`:`周围额外的圆括号是须要的：
```
julia> :(:)
:(:)

julia> :(::)
:(::)
```

# 表达式和计算

## 引用

字符`:`的另一个语义目的是创造表达式对象，不显式采用`Expr`构造函数。
把这个称作引用（refer to as）。
字符`:`后紧跟一对圆括号，包裹单个Julia代码声明，产生一个基于该闭包代码的`Expr`对象。
这里有个用来引用算法表达式的简易格式：
```
julia> xd = :(k*x+b)
:(k * x + b)

julia> typeof(xd)
Expr
```

查看该表达式的结构，尝试`xd.head`和`xd.args`或用如上所述的`dump`或`Meta.@dump`。
注意，等价的表达式可用`Meta.parse`函数或直接用`Expr`构造形成：
```
julia> xe = Meta.parse("k*x+b")
:(k * x + b)

julia> xf = Expr(:call, :+, Expr(:call, :*, :k, :x), :b)
:(k * x + b)

julia> xd == xe == xf
true
```
解析器提供的表达式通常只有符号，别的表达式和字面值作为它的参数，然而Julia代码构造的表达式可有任意的运行时值，没有作为参数的字面形式。
在上述例子中，`+`和`b`式符号，`*(k,x)`式子表达式。
下面的例子中，`9527`是`Int64`字面值：
```
julia> :(x*x - 9527)
:(x * x - 9527)
```

对于多个表达的引用，还有一种语法形式：由`quote`和`end`包裹的代码块。
```
julia> xg = quote
         x = 0
         y = 1
         z = 2
       end
quote
    #= REPL[26]:2 =#
    x = 0
    #= REPL[26]:3 =#
    y = 1
    #= REPL[26]:4 =#
    z = 2
end

julia> typeof(xg)
Expr
```

## 篡改（字面格式化）

用值参数直接构造`Expr`是很猛，但是`Expr`构造函数可冗长乏味的和Julia语法相比。
作为一个备胎（alternative），Julia允许字面或表达式到引用表达式的篡改。
篡改用`$`前缀表示。

在本例中，变量`sb`的值被篡改：
```
julia> sb = 1314
1314

julia> xh = :($sb + b)
:(1314 + b)
```

不支持篡改到为引用的表达式，会引起编译时错误：
```
julia> $sb + b
ERROR: syntax: "$" expression outside quote

julia> :$sb + b
ERROR: syntax: extra token "sb" after end of expression

julia> :($sb) + b
ERROR: UndefVarError: b not defined
Stacktrace:
 [1] top-level scope at none:0
```

下个例子中，元组`(1,2,3)`篡改为表达式作条件测试：
```
julia> xi = :(x in $:((1,2,3)))
:(x in (1, 2, 3))
```

用于表达式篡改的`$`有意让人联想到【[字符串篡改](./字符串.md "Strings")】和【[命令篡改](./运行外部程序.md "Running External Programs")】。
表达式篡改让复杂Julia表达式便捷、可读的规划建设。

## 抛雪球算法插值（splatting interpolation）

注意到`$`篡改语法允许插入单个表达式到闭包表达式中。
偶尔，要把表达式数组中所有的元素（表达式）作为`$`所包裹的表达式的参数。
这可以通过语法`$(xs...)`完成。
举个例子，下面的代码产生一个函数调用，参数的个数是以编程方式检测的。
```
julia> xs = [:x, :y, :z]
3-element Array{Symbol,1}:
 :x
 :y
 :z

julia> :(fuck(9527, $(xs...)))
:(fuck(9527, x, y, z))
```

## 嵌套引用

自然而然地，引用包含别的引用表达式地表达式是可能的。
理解篡改在这些场景中是如何工作的有点棘手（a bit tricky）。
考虑下面的例子：
```
julia> xj = :(9527 + 1314)
:(9527 + 1314)

julia> xk = quote quote $xj end end
quote
    #= REPL[40]:1 =#
    $(Expr(:quote, quote
    #= REPL[40]:1 =#
    $(Expr(:$, :xj))
end))
end
```

注意到结果包含的`Expr(:$, :xj)`表示`xj`尚未被计算。
换句话说，属于内部引用表达式的`$`表达式，连同它的参数，仅当内部引用表达式被计算（`eval`）时被计算。
```
julia> eval(xk)
quote
    #= REPL[40]:1 =#
    9527 + 1314
end
```

然而，外部`quote`表达式能篡改内部`quote`的值。
这通过多个`$`实现：
```
julia> xl = quote quote $$xj end end
quote
    #= REPL[42]:1 =#
    $(Expr(:quote, quote
    #= REPL[42]:1 =#
    $(Expr(:$, :(9527 + 1314)))
end))
end
```

注意到`:(9527 + 1314)`目前出现在结果中，而不是`:xj`符号。
计算该表达式生成一个被篡改的结果：
```
julia> eval(xl)
quote
    #= REPL[42]:1 =#
    10841
end
```

该行为背后的直觉是`xj`对每个`$`计算一次：一个`$`的作用和`eval(:xj)`相似，给出`xj`的值，因为两个`$`相当于`eval(eval(:xj))`。

## 引用节点

在抽象语法树（AST）中引用常见的表现形式是`head`为`:quote`的`Expr`：
```
julia> dump(Meta.parse(":(9527+1314)"))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Int64 9527
        3: Int64 1314
```
正如所见，这种表达式支持以`$`插值。
然而，有些场景中，不执行插值的代码引用是必须的。
这种引用尚无语法，只是内部表达为`QuoteNode`类型的对象。
解析器为如符号的简单引用项生成`QuoteNode`：
```
julia> dump(Meta.parse(":x"))
QuoteNode
  value: Symbol x
```
`QuoteNode`也可用于特定的高级元编程任务。

## [eval](../基础/精要.md "Base: Essentials-Syntax-MainInclude-eval")及其影响

给定一个表达式对象，即可让Julia采用`eval`在全局作用域执行它：
```
julia> :(9527 + 1314)
:(9527 + 1314)

julia> eval(ans)
10841

julia> exp = :(x + y)
:(x + y)

julia> eval(exp)
ERROR: UndefVarError: x not defined
Stacktrace:
 [1] top-level scope at none:0
 [2] eval at .\boot.jl:319 [inlined]
 [3] eval(::Expr) at .\client.jl:389
 [4] top-level scope at none:0

julia> x = 9527; y = 1314;

julia> eval(exp)
10841
```
每个[模块](./模块.md "Modules")有其`eval`函数，用来在它的全局作用域计算表达式。
传递给`eval`的表达式不限制返回值——亦有改变模块环境的闭包状态的副作用：
```
julia> exp = :(z = 250)
:(z = 250)

julia> z
ERROR: UndefVarError: z not defined

julia> eval(exp)
250

julia> z
250
```
这里，一个表达式对象的计算导致给全局变量`z`的赋值。

由于表达式只是可程序构建病随后计算的`Expr`对象，可能动态产生任意代码然后用`eval`执行。
这儿给出一个简单例程：
```
julia> a = 1.0
1.0

julia> exp = Expr(:call, :+, a, :b)
:(1.0 + b)

julia> a = 2.0; b = 0.2;

julia> eval(exp)
1.2

julia> a
2.0

julia> b
0.2
```
可见`a`的值用来构造`exp`表达式，即将`+`函数应用给`1.0`和变量`b`。
注意`a`和`b`之间重大的使用区别：

- 表达式构造时变量`a`的值采用立即数，因此当计算表达式时`a`的值是什么无关紧要，值已经是`1.0`了，和`a`变量此时的值无关。
- 另一方面，符号`:b`用于构造表达式，和变量`b`的值此时无关，`:b`只是个符号，没必要定义值，在计算表达式时，符号`:b`的值通过查找`b`变量的值来解决。

## 表达式中的函数

如上边暗示的，Julia的一个极其有用的特性是自行生成和操纵Julia代码的能力。
已经看过函数返回`Expr`对象的例子：`parse`函数，输入一个Julia代码字符串、输出对应的`Expr`。
函数也可以有一个或多个`Expr`对象作为参数，返回另一个`Expr`。
这里展示一个简单的、刺激的例程：
```
julia> function mathexpr(op, op_, op__)
         expr = Expr(:call, op, op_, op__)
         return expr
       end
mathexpr (generic function with 1 method)

julia> expr = mathexpr(:+, 9527, Expr(:call, :*, 657, 2))
:(9527 + 657 * 2)

julia> eval(expr)
10841
```

作为另一个例程，下面的函数将任何数值参数双倍，但不理睬表达式：
```
julia> function makeexpr(op, opr_, opr__)
         oprf_, oprf__ = map(x -> isa(x, Number) ? 2*x : x, (opr_, opr__))
         expr = Expr(:call, op, oprf_, oprf__)
         return expr
       end
makeexpr (generic function with 1 method)

julia> makeexpr(:+, 9527, 1314)
:(19054 + 2628)

julia> makeexpr(:+, 9527, Expr(:call, :*, 657, 2))
:(19054 + 657 * 2)
```

# 宏
