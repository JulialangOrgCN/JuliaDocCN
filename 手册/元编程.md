在Julia中，Lisp最大的遗产就是支持元编程。
如Lisp一样，Julia用和编程语言本身相同的数据结构表达代码。
由于对象所表现的代码可从编程语言内部创建和操作，程序改变和生成自有代码是可能的。
这允许复杂代码生成，无须额外构建步骤，且允许[抽象语法树](https://en.wikipedia.org/wiki/Abstract_syntax_tree)级别的真Lisp风格宏操作。
相反，预处理宏系统，如C/C++的，视在任何实际解析或解释发生之前执行字面处理和替换的。
因为Julia的全部数据类型和代码由Julia数据结构表达，强大的[反射](https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29)能力可用来像任何别的数据那样探测程序内部及其类型。

# 程序表达

每个Julia程序以字符串入世：
```
julia> program = "9527 + 1314"
"9527 + 1314"
```

**接下来发生了什么？**

下一步是[解析](https://en.wikipedia.org/wiki/Parsing#Computer_languages)每个字符换为叫做表达式的对象，由Julia类型`Expr`表示：
```
julia> xa = Meta.parse(program)
:(9527 + 1314)

julia> typeof(xa)
Expr
```

`Expr`对象包含两部分：

- 一个`Symbol`标识表达式的种类。一个符号就是一个[缓存（interned）字符串](https://en.wikipedia.org/wiki/String_interning)标识符（更多讨论后边说）。

    ```
    julia> xa.head
    :call
    ```

- 表达式参数，可以是符号、别的表达式或字面值。

    ```
    julia> xa.args
    julia> xa.args
    3-element Array{Any,1}:
        :+
    9527
    1314
    ```
