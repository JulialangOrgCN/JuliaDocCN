类型系统已然习惯地分为风格迥异的两大阵营：

- 静态类型系统：程序运行之前每个表达式必须有确定的类型。
- 动态类型系统：程序运行之前对于类型一无所知，实际值由程序就地计算。

面向对象允许静态类型语言某些灵活，编码时不写编译时可知的确切类型。
编写执行不同类型代码的能力叫多态（polymorphism）。
典型动态类型语言的所有代码都是多态的，只有显式检查类型或在运行时碰到对象未能支持的操作，代码不限制任何值的类型。

Julia的类型系统是动态的，但是汲取静态类型系统的某些优势，指示确定值得指定类型成为可能。
这会成为生成高效代码的得力助手，但更显著的是，允许方法根据函数参数的类型重载、和语言深度集成。
探索方法重载，详见【[方法](./方法.md "Methods")】，但却植根于这里表述的类型系统。

Julia缺省类型的值默认任意类型。
因此可以无须显式应用类型来编写有用的函数。
当需要额外的表达式时，不管怎样，很容易逐步引入明确的类型注解到之前的“无类型”代码。
添加注解旨在三个主要目标：利用Julia强大的多重分派（multiple-dispatch）机制，提升可读性和捕捉码农错误。

用【[类型系统](https://en.wikipedia.org/wiki/Type_system)】术语阐述Julia，她是：动态的、主格的（nominative）、参数的（parametric）。
一般类型可被参数化，类型之间的层级关系是[明确公开的](https://en.wikipedia.org/wiki/Nominal_type_system)，而不是被[继承架构](https://en.wikipedia.org/wiki/Structural_type_system)所隐含的。
一个Julia类型系统特别不同的特征是具体类型可能不会相互为子类型：全部具体类型都是最终的且大概只有抽象类型为其亲类型。
但这可能第一印象似乎过度严格，这样做有很多受益结果、缺点少得惊人。已经证明继承行为比继承结构要重要得多，两者都继承给传统面向对象语言带来不小的麻烦。
别的应该正面提及的Julia类型系统的高级方面有：

- 没有对象和非对象之分：Julia中一切都是真正的对象，具体类型取决于单个、全连接的类型图，其中所有节点平等、都是一流类型。
- 编译时类型概念没意义：一个值仅有的类型就是运行时的真实类型，面向对象语言结合多态机制的静态编译称作“运行时类型”将此区分开来（make this distinction significant）。
- 仅值有类型而不是变量：变量是绑定到值的简单名称。
- 具体类型抽象类型均可被别的类型参数化：也能被符号、任何类型的值——只要`isbits`返回真（本质上像C类型或结构体不含指向别的对象指针的数字和布尔值）参数化，元组亦在此列（also by tuples thereof）。非必须引用或限制，类型参数可以省略。

Julia的类型系统被设计得强大而富有表现力、清晰、直观且低调（unobtrusive）。
许多Julia码农撸代码从来不觉得需要显式应用类型。
然而某些编程，带上类型声明，不敢怎样还是会让代码变得清晰、简单、快速且更健壮。

# 类型声明

操作符`::`可用来给程序的表达式和变量附加类型注解。这么做主要有两个理由：

- 作为断言帮助码农确认程序如期工作；
- 给编译器提供额外的类型信息，在某些场景会提升性能。

当添加了类型注解的表达式计算值的时候，操作符`::`理解为“是该类型实例”。
可用在任何断言左边表达式的值是右边类型实例的地方。
当右边的类型是具体的，左边的值必须以该类型实现，回想下，所有具体类型都是最终的（不可更改的），因此不肯能出现某个具体类型是另外一个具体类型子类或亲类的情况。
当右边的类型是抽象的，左边值的类型必须满足是该抽象类型子类。
如果类型断言是假的，抛出异常，否则返回左边值。
```
julia> (9527+1314)::AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got Int64
Stacktrace:
 [1] top-level scope at none:0

julia> (9527+1314)::Int
10841
```
这允许任何表达式就地附加一个类型断言。

当添加类型注解到一个赋值语句左边的变量或作为本地声明的一部分的时候，操作符`::`的意思略有不同，声明变量总是指定的类型，正如C等静态类型语言的类型声明。
每个分配给变量的值用`convert`转换为声明的类型。
```
julia> function cto()
         age::Int8 = 48
         return age
       end
cto (generic function with 1 method)

julia> cto()
48

julia> typeof(ans)
Int8
```
该特性在避免如果赋值语句的变量类型被意外修改引发的性能陷阱（gotchas）方面很有用。

这种声明效果仅发生在指定的上下文中：
```
julia> local x::Int8 # 本地类型声明

julia> x::Int8 = 0 # 目前不支持全局变量类型声明
ERROR: syntax: type declarations on global variables are not yet supported

julia> function se()
         age::Int8 = 35 # 作为赋值语句左边的一部分
         return age
       end
se (generic function with 1 method)

julia> se()
35
```

而且作用于当前整个作用域，即使是声明之前的。
目前**类型声明还不能用在全局作用域**，举例来说，在JuliaREPL中也没有常量类型全局对象。

类型声明也可以附加到函数定义：
```
julia> function codepeasant(post)::String
         if post == "项目管理"
           return "嚣张"
         end
         return "苦逼"
       end
codepeasant (generic function with 2 methods)

julia> codepeasant("Python专家")
"苦逼"

julia> codepeasant("JavaScript专家")
"苦逼"

julia> codepeasant("Openstack专家")
"苦逼"

julia> codepeasant("Container专家")
"苦逼"

julia> codepeasant("Go专家")
"苦逼"

julia> codepeasant("Julia专家")
"苦逼"

julia> codepeasant("SDS专家")
"苦逼"
```
该函数返回行为正如带类型声明的变量赋值：（返回）值总是转换成`String`类型。

# 抽象类型

抽象类型不能实例化，仅作为类型图中的节点伺服，从而描述具体类型的相关集合：那些具体类型是这些抽象类型的“子孙”。
开始抽象类型，尽管没有实例，因为抽象类型是类型系统的主干：形成概念上的层次，让Julia的类型系统不止是一堆对象实现。

回想【[整型数字和浮点型数字](./整型数字和浮点型数字.md "Integers and Floating-Point Numbers")】中介绍了各种各样的数值类型：`Int8`、`UInt8`、`Int16`、`UInt16`、`Int32`、`UInt32`、`Int64`、`UInt64`、`Int128`、`UInt128`、`Float16`、`Float32`和`Float64`。
尽管这些具体类型有着不同的表达尺寸，Int8、Int16、Int32、Int64、Int128的共同点是有符号整型类型，UInt8、UInt16、UInt32、UInt64、UInt128共同点是无符号整型类型，而Float16、Float32、Float64是明显不同于整型的浮点型。
对代码片段通常是有意义的，举例说明，如果只有参数是某种整型，但并非真的取决于某个特定整型，但浮点型肯定不会接受。
抽象类型允许一个类型层级的构建，提供具体类型可适应的上下文。
这允许码农，比如简化接受任意整型类型编程、不局限某算法于指定的整型类型。

抽象类型用`abstract type`关键字（组）声明。
声明抽象类型的一般语法：

    abstract type <name> end
    abstract type <name> <: <supertype> end

关键字（组）`abstract type`引入一个新的名为`<name>`的抽象类型。
名称后边可选地跟着`<:`（真让喜XML编辑器为难）、已存在地类型，表明这个新声明的抽象类型是这个已存在类型的子类型。

*习惯上把这个已存在的类型称为新类型的父类型（以后看到“亲类”也是这个意思——男女平等且父母同尊）。*

不提供亲类型，默认亲类型是`Any`（Python中的`type`——中国神话中的盘古），是个预定义的类型，所有对象都是它的实例、所有类型都是它的子类型。
在类型理论中，通常称`Any`为“顶（鼎）”，因为它站在类型图的顶端！
猪吏还有个预定义的抽象类型，名曰`bottom`（刺痛笔者的心），
趴在类型图的最下面，写作`Union{}`（赏个高端的代号）。
这个`bottom`和`Any`相对，不存在`Union{}`的实例，所有类型都是`Union{}`的亲类型。

一起思考构成Julia数值层级的抽象类型：

    abstract type Number end
    abstract type Real          <: Number end
    abstract type AbstractFloat <: Real end
    abstract type Integer       <: Real end
    abstract type Signed        <: Integer end
    abstract type Unsigned      <: Integer end

类型`Number`是类型`Any`的直接子类型，类型`Real`是类型`Number`类型的子类型。
按顺序`Real`类型有两个子类型（其实有更多——这儿暂时只提这两个）：`Integer`和`AbstractFloat`，将世界分为整数表达和实数表达。
实数表达当然不但包括浮点类型，也还包括别的类型，如分数（有理数）。
因此`AbstractFloat`是`Real`的一个子类型，只囊括实数表达的浮点型部分。
整型进一步分割为`Signed`和`Unsigned`两种（*其实还有`Bool`类型*）。

操作符`<:`一般表示“是后者的子类型”的意思，如上述例程的用法，声明右边的类型是左边新类型的亲类型。
也可以用在表达式中，判断左边被操作对象是右边被操作对象的子类型否：
```
julia> Bool <: Integer
true

julia> Bool <: AbstractFloat
false
```

抽象类型*最*重要的用途是提供具体类型的默认实现。看一个例子并思考：
```
julia> function nbjoint(n, b)
         n * b
       end
nbjoint (generic function with 1 method)
```
首先要明确上述例子中参数声明等价于`n::Any`和`b::Any`。
当该函数被调用，拿`nbjoint("huaan", "qiuxiang")`来说（say as），重载（器）选择最具特效的、名为`nbjoint`、匹配调用参数的方法（查看【[方法](./方法.md "Methods")】获取关于多路分发-多重分派-重载的更多信息）。

假设上述方法就是能找到的最佳函数，Julia接着基于上述给定的一般函数内部定义并编译一个称作`nbjoint`的方法，特定两个`String`类型参数，也就是说，隐式地定义并编译。
```
julia> function nbjoint(n::String, b::String)
         n * b
       end
nbjoint (generic function with 2 methods)
```
最后，Julia调用该方法。

这样，抽象类型允许码农编写以后用作许多具体类型组合（参数函数的）默认方法的一般函数。
感谢重载（感谢党的好政策），码农完全控制用最匹配的方法还是用默认的方法。

注意一个要点，码农依赖抽象类型参数搞的函数没有性能损失，因为为每种具体类型（组合）重新编译了精确版本供使唤。
可能会有性能问题，然而，在函数参数场景是抽象类型容器，详查【[性能窍门](./性能窍门.md "Performance Tips")】。

# 原始类型

原始类型就是数据由普通老式比特组成的具体类型。
典型的原始类型案例就是整型和浮点型数值。
不同于大多数编程语言，Julia让码农声明自己的原始类型，而不是提供固定的内建原始类型集合。
实际上，标准的原始类型均在语言本身有定义。

    primitive type Float16 <: AbstractFloat 16 end
    primitive type Float32 <: AbstractFloat 32 end
    primitive type Float64 <: AbstractFloat 64 end

    primitive type Bool <: Integer 8 end
    primitive type Char <: AbstractChar 32 end

    primitive type Int8    <: Signed   8 end
    primitive type UInt8   <: Unsigned 8 end
    primitive type Int16   <: Signed   16 end
    primitive type UInt16  <: Unsigned 16 end
    primitive type Int32   <: Signed   32 end
    primitive type UInt32  <: Unsigned 32 end
    primitive type Int64   <: Signed   64 end
    primitive type UInt64  <: Unsigned 64 end
    primitive type Int128  <: Signed   128 end
    primitive type UInt128 <: Unsigned 128 end

声明原始类型的一般语法如下：

    primitive type <name> <bits> end
    primitive type <name> <: <supertype> <bits> end

比特（bits）数量表示该类型需要的存储空间，名称（name）是新类型的名称。
原始类型也可以选择亲类型（supertype），如果亲类型缺失，默认亲类型为`Any`。
上述`Bool`类型声明，意思是一个布尔类型值占八个比特，以整型为亲类型。
目前，**仅支持多个八比特尺寸**。
因此，布尔值，尽管实际需要一个比特，也不能声明为小于八比特。

类型`Bool`、`Int8`和`UInt8`都有特定的表达，是八比特内存块。
因为Julia的类型系统是主格的（nominative），无论如何，这些类型之间不能互换，尽管有完全相同的结构。
一个基本的区别是这些类型有不同的亲类型：`Bool`的直接亲类型是`Integer`，`Int8`的直接亲类型是`Signed`，`UInt8`的直接亲类型是`Unsigned`。
所有`Bool`、`Int8`、`UInt8`之间的其余区别是行为的问题——函数定义的当给定这些类型对象作为参数时的动作方式。
这就是必须主格类型系统的理由：如果架构检测类型，按轮换命令行动，那将`Bool`参数和`Int8`或`UInt8`参数行为区分开来是不可能的。

# 复合类型

[复合类型](https://en.wikipedia.org/wiki/Composite_data_type)在众多编程语言中称作记录、结构体或对象。
一个复合类型就是一堆命名字段，它（复合类型）的一个实例可以当作单个值。
在很多编程语言中，复合类型是仅有的用户可自定义类型，截止目前，也是Julia最常用的用户自定义类型。

在主流面向对象编程语言中，如C++、Java、Python和Ruby，复合类型也有对应的具名函数（相对于匿名函数），组合成为“对象（object）”。
在更纯粹的变相对象语言中，如Ruby和Smalltalk，所有值都是对象，无论是复合类型与否。
在略不纯的面向对象编程语言中，如C++、Java，某些值，如整数和浮点数，不是对象，而用户自定义的复合类型是拥有对应方法的真实对象。
在Julia中，所有值都是对象，但函数并没有绑定到所操作的对象上。
这是**必须的（好好念）**，因为Julia通过重载选择执行哪个函数，意味着选择方法的时候，函数所有参数的全部类型都考虑在内的，而不只是第一个（查看【[方法](./方法.md "Methods")】获取更多有关方法和重载的信息）。
因此，函数只归属于第一个参数是不合适的。
**组织方法到函数对象，而不是每个对象都带有命名的方法包，让编程语言设计受益匪浅。**

复合类型通过`struct`关键字及紧跟的字段名块、可选的类型注解（用`::`操作符）构成：
```
julia> struct MaNong
           name::String
           age::UInt8
           skills
           others
       end
```
没有类型注解的字段默认`Any`，能把持任何类型的值（还是带钩的）。

创建类型`MaNong`的对象，就像函数调用那样，给字段塞值。
```
julia> xiucai = MaNong("xiugai",0,["加班", "思路广", "欢乐多", "便宜", "好用", "活好", "话少", "英俊潇洒", "风流倜傥", "诗词若滔滔江水", "文赋如黄河泛滥", "……"],"www.nagexiucai.com")
MaNong("xiugai", 0x00, ["加班", "思路广", "欢乐多", "便宜", "好用", "活好", "话少", "英俊潇洒", "风流倜傥", "诗词若滔滔 江水", "文赋如黄河泛滥", "……"], "www.nagexiucai.com")
```
当像搞函数一样搞一个类型叫做构造函数。
两个自动生成的构造函数（叫做默认构造函数）。
一个接受任何参数，调用`convert`将参数转换成字段类型；一个接受精确匹配字段类型的参数。
一次搞两个默认构造函数的原因是：让创建新定义的类型实例更简单（貌似想到某些公司令人作呕的宣传语），大家再也不用担心替换默认构造函数这茬儿啦。

由于`skills`和`others`两个字段不受类型约束，任何值都可以。然而`name`字段的值必须能转换成`String`，`age`字段的值必须能转换成`UInt8`。
```
julia> xiucai = MaNong(9527,0,["加班", "思路广", "欢乐多", "便宜", "好用", "活好", "话少", "英俊潇洒", "风流倜傥", "诗词若滔滔江水", "文赋如黄河泛滥", "……"],"www.nagexiucai.com")
ERROR: MethodError: Cannot `convert` an object of type Int64 to an object of type String
Closest candidates are:
  convert(::Type{T<:AbstractString}, ::T<:AbstractString) where T<:AbstractString at strings/basic.jl:207
  convert(::Type{T<:AbstractString}, ::AbstractString) where T<:AbstractString at strings/basic.jl:208
  convert(::Type{T}, ::T) where T at essentials.jl:154
Stacktrace:
 [1] MaNong(::Int64, ::Int64, ::Array{String,1}, ::String) at .\REPL[1]:2
 [2] top-level scope at none:0

julia> xiucai = MaNong("xiugai","1314",["加班", "思路广", "欢乐多", "便宜", "好用", "活好", "话少", "英俊潇洒", "风流倜 傥", "诗词若滔滔江水", "文赋如黄河泛滥", "……"],"www.nagexiucai.com")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type UInt8
Closest candidates are:
  convert(::Type{T<:Number}, ::T<:Number) where T<:Number at number.jl:6
  convert(::Type{T<:Number}, ::Number) where T<:Number at number.jl:7
  convert(::Type{T<:Integer}, ::Ptr) where T<:Integer at pointer.jl:23
  ...
Stacktrace:
 [1] MaNong(::String, ::String, ::Array{String,1}, ::String) at .\REPL[1]:2
 [2] top-level scope at none:0
```

可用`fieldnames`函数查找复合类型的字段名列表：
```
julia> fieldnames(MaNong)
(:name, :age, :skills, :others)
```

用`struct`声明的复合对象是不可变的；构造完成后不能修改。乍一看感觉奇怪（不是第一次啦），有若干优势：

- 更高效：打包为数组；某些场景编译器避免为整个不可变对象分配空间。
- 不可能侵犯类型构造函数提供的不变式。
- 包含不可变对象的代码更容易推测。

一个不可变对象可能包含可变对象，如数组作为字段。
这些被包含的可变对象保持可变；**只是不可变对象本身不能改变为指到别的对象**。

若有需要，【可变复合类型】可用`mutable struct`关键字（组）声明，后边有叙述。

无字段的不可变复合类型是单例的；只能有一个该类型的实例。
```
julia> struct NoFieldsImmutableCompositeTypeIsSingleton
       end

julia> NoFieldsImmutableCompositeTypeIsSingleton() === NoFieldsImmutableCompositeTypeIsSingleton()
true

julia> struct AnotherNoFieldsImmutableCompositeTypeIsSingleton
       end

julia> AnotherNoFieldsImmutableCompositeTypeIsSingleton() === NoFieldsImmutableCompositeTypeIsSingleton()
false
```
恒等（`===`）函数确认构造的两个无字段的不可变复合实例是单例的（两次构造的对象**一模一样**）。
【单例类型】后边有更深入讨论。

关于如何创建复合类型实例要说的还有很多，但这些讨论基于【参数类型】和【[方法](./方法.md "Methods")】，重要到足以独立成章（【[构造函数](./构造函数.md "Constructors")】）。

# 可变复合类型

如果一个复合类型以`mutable struct`关键字（组）替代`struct`关键字声明，则该类型的实例是可变的。

![](../插图/Manual-Types-Mutable-Composite-Object.png "Mutable Composite Object")

为了支持可变，这种对象通常在分配在堆上，有稳定的内存地址。
一个可变对象犹如一个小型容器，可超时（相对于栈）持有不同值，可以仅凭其内存地址确保一致。
相反地，不可变类型的实例对应指定的字段值——字段值只身传达所属对象的全部（多疑的骚年不信）。
决定一个类型（对象）是否可变（这下说字段呢），问下两个实例的同名字段能认为是同一个对象否，或者如果任何时候（over time）需要独立（各自）修改否。
若可认为是同一个对象或不需要各自修改，则是不可变对象。

扼要重述，Julia中定义的不可变对象两个本质属性：

- 不允许修改不可变类型的值。
  - 对于比特类型
  - 对于符合类型
- 不可变类型对象可被编译器自由拷贝，因为不可变对象让以编程方式搞得源对象和拷贝对象不同是不可能。
  - 特别地
  - 可变值，另一方面是开辟在堆存储空间的

# 公开类型
