在Julia中模块是分离的变量工作区，例如引入一个新的全局作用域。
是带分隔符的语法（delimited syntactically），在`module Name`和`end`内。
模块允许创建顶层定义（即全局变量）而不用担心自己的代码和别人的代码一起用的时候的命名冲突。
在一个模块内部，可以控制来自别的模块的哪些命名可见（通过导入），可以指定哪些本模块的命名可暴露（通过导出）。

下述例程演示包的主要特征。
并非意味着可运行，但为解说目的而展示：
```
module MyModule
using Lib

using BigLib: thingx, thingy

import Base.show

export MyType, fuck

struct MyType
    x
end

bar(n) = 2n

fuck(mt::MyType) = bar(mt.x) + 9527

show(io::IO, mt::MyType) = print(io, "1314")
end
```
注意上述代码风格没有缩进模块体，因为会通常导致整个文件都缩进。

该模块定义了一个`MyType`类型，两个函数`bar`和`fuck`。
函数`fuck`和类型`MyType`被导出，因此可用于导入到别的模块中。
函数`bar`是`MyModule`模块的私有函数。

声明`using Lib`意思是该模块调用`Lib`将被用于按需解决命名。
当碰到未在当前模块中定义的全局变量，系统将会在`Lib`导出的变量中搜索，并将搜索到的命名导入其中。
这意味着，所有当前模块中用到的那个全局变量都会解析到`Lib`中的定义。

声明`using BigLib: thingx, thingy`仅从`BigLib`引入标识符`thingx`和`thingy`到当前作用域。
如果这些命名引用的是函数，则给这些函数添加方法是不允许的（只能用而不能扩展）。

关键字`import`支持和`using`相同的语法，但一次只操作在一个命名。
并且`import`并未像`using`一样将模块添加到搜索路径。
导入函数上`import`还和`using`有区别，前者导入的函数可在当前作用域中扩展新方法。

在上述`MyModule`中，想要给标准`show`函数添加方法，因此需要些`import Base.show`。
仅通过`using`可见的函数命名不可被扩展。

一旦一个变量被`using`或`import`操作可见，当前模块便不能创建同名对象。
导入的变量是只读的；给全局变量赋值总是影响当前模块自己的变量，或者抛出错误。

# 模块用法汇总

加载一个模块，要用到两个关键字：`using`和`import`。
要理解这两个关键字的区别，考虑下述例程：
```
module MyModule

export x, y

x() = "x"
y() = "y"
z() = "z"

end
```
在该模块，咱导出`x`和`y`函数（用`export`关键字），还有个未导出的`z`函数。
加载模块及其内部函数到当前工作区有若干方式：

|导入命令|给当前作用域带来了什么|可用的方法扩展|
|:---|:---|:---|
|`using MyModule`|所有导出的命名（`x`和`y`），`MyModule.x`、`MyModule.y`和`MyModule.z`。|`MyModule.x`、`MyModule.y`和`MyModule.z`。|
|`using MyModule: x, z`|`x`和`z`。|无|
|`import MyModule`|`MyModule.x`、`MyModule.y`和`MyModule.z`。|`MyModule.x`、`MyModule.y`和`MyModule.z`。|
|`import MyModule.x, MyModule.z`|`x`和`z`。|`x`和`z`。|
|`import MyModule: x, z`|`x`和`z`。|`x`和`z`。|

## 模块和文件

文件和文件名几乎和模块无关；模块仅和模块表达式相关。
每个模块可以有多个文件，也可以一个文件多个模块。
```
module Fuck

include("alice.jl")
include("bob.jl")

end
```
在不同模块中包含相同代码提供类似混合（mixin）的行为。
可以运用该特性以不同基础定义执行相同代码，举个例子，以某些操作的安全版本执行测试代码：
```
module Normal
include("normal.jl")
end

module Testing
include("safes.jl")
include("normal.jl")
end
```

## 标准模块

有三个重要的标准模块：**Main**、**Core**、**Base**。

**Main**是顶层模块，且Julia以Main为当前模块开始。在提示符（prompt）进入Main时定义的变量，可通过`varinfo()`列出。

**Core**包含所有认为是语言内建的标识符，也就是，是编程语言核心的一部分，而不是库的。每个模块隐式指定`using Core`，因为没有这些定义，啥也干不了。

**Base**是包含基本功能（即[`base/`](https://github.com/JuliaLang/julia/tree/master/base)下的内容）的模块。所有模块隐式包含`using Base`，因为绝大多数情况下需要Base中的定义。

## 默认顶层定义和裸模块

除了`using Base`，模块也自动包含`eval`和`include`函数定义，这些函数用来计算该模块全局作用域内的表达式和文件。

如果这些默认的定义不是想要的，可以用`baremodule`关键字定义（注意`Core`仍然如上述被导入）。
按照`baremodule`，标准`module`看起来如是：
```
baremodule BM

using Base

eval(x) = Core.eval(BM, x)
include(p) = Base.include(BM, p)

# 继续表演

end
```

## 相对模块路径和绝对模块路径

给定`using Fuck`声明，系统查阅内部顶层模块表寻找名为`Fuck`的模块。
如果该模块不存在，系统尝试`require(:Fuck)`，它典型地导致从已安装地包中加载代码。

然而，某些模块包含子模块，这意味着有些时候需要访问一个非顶层模块。
有两种方式。
第一种用绝对路径，如`using Base.Sort`。
第二种用相对路径，让导入当前模块地子模块或任何它的闭包模块很容易：
```
module Parent

module Utils

# 继续表演

end

using .Utils

# 更多节目

end
```
这里的`Parent`模块包含`Utils`子模块，而且在`Parent`中的代码想要看到`Utils`的内容。
这可以`using`以句号开始的路径来实现。
添加更多前导句号上移更多模块层级。
如`using ..Utils`将在`Parent`闭包模块中查找`Utils`，而不是在`Parent`自身内。

注意，相对导入修饰语仅在`using`和`import`声明中有效。

## 模块文件路径

全局变量`LOAD_PATH`包含Julia调用`require`时查找模块的目录集合。
可以通过`push!`扩展。
```
push!(LOAD_PATH, "/Path/To/My/Module/")
```
将该声明放入`~/.julia/config/startup.jl`将会在每次启动Julia时扩展`LOAD_PATH`，模块加载路径可通过定义环境变量`JULIA_LOAD_PATH`来扩展。

## 命名空间杂七八糟

如果命名是合格的（如`Base.sin`），则可被访问，即使未被导出。
调试时，这通常有用。
也可以将合格的用作函数名并添加方法。
然而，因为引起语法歧义，如果希望给不同模块中仅包含符号的名称函数添加方法，举个例子，如操作符“Base.+”，必须用`Base.:+`引用之。
如果操作符不止一个字符，必须用圆括号包裹起来，如`Base.:(==)`。

在导入导出声明中，宏名用`@`编写，例如`import M.@m`。
别的模块中的宏，可用`M.@m`或`@M.m`调用。

语法`M.x = y`在别的模块中给一个全局变量赋值无效；全局赋值总是模块本地的。

变量名无须通过声明为`global x`被保留。
这避免加载之后全局初始化的命名冲突。

## 模块初始化和预编译

大的模块需要若干秒来加载，因为执行模块中全部声明经常包含编译大量的代码。
Julia创建模块的预编译缓存来减少这个耗时。

一个增量预编译模块文件被创建且当用`import`或`using`加载模块是被自动使用。
这将导致第一次导入模块时该模块被编译。
可选地，可以手动调用`Base.compilecache(modulename)`。
作为结果的缓存文件将保存在`DEPOT_PATH[1]/compiled/`。
随后，模块基于`using`或`import`自动预编译，无论任何依赖变化时；依赖是模块所导入的，Julia构建的，所包含的文件，或在模块文件中`include_dependency(path)`声明的隐式依赖。
