Julia的许多强大且可扩展的特性来自一组日常使用的接口。
通过给某定制类型扩展些许指定方法，该类型的对象不仅接收那些功能（函数），也用于基于那些行为一般构建的其余方法。

# 迭代

|必要方法|简要描述|
|:---|:---|
|`iterate(iter)`|返回首项的元组和初始状态（或`nothing`若为空）。|
|`iterate(iter, state`|返回后项和后状态（或`nothing`若无更多项）。|

|重要可选方法|默认定义|简要表述|
|:---|:---|:---|
|必是`IteratorSize(IterType`|`HasLength`|`HasLength()`、`HasShape{N}()`、`IsInfinite()`、`SizeUnknown()`其一，视情况而定（as appropriate）。|
|`IteratorEltype(IterType)`|`HasEltype`|或`EltypeUnknown()`、或`HasEltype()`，视情况而定。|
|`eltype(IterType)`|`Any`|是`iterate`返回的元组的第一个条目的类型。|
|`length(iter)`|未定义|若已知，则为元素个数。|
|`size(iter, [dim...])`|未定义|若已知，则为每个维度种元素的个数。|

|单表`IteratorSize(IterType)`返回值|必要方法|
|:---|:---|
|`HasLength()`|`length(iter)`|
|`HasShape{N}()`|`length(iter)`和`size(iter, [dim...])`|
|`IsInfinite()`|无|
|`SizeUnknown()`|无|

|单表`IteratorEltype(IterType)`返回值|必要方法|
|:---|:---|
|`HasEltype()`|`eltype(IterType)`|
|`EltypeUnkown()`|无|

连续迭代由`iterate`函数实现。
Julia迭代在对象外部保持迭代状态，而不是改变所遍历的对象。
迭代返回值总要么是元组和状态、要么是`nothing`如果没有剩余元素。
状态对象会在下一次迭代回传给迭代函数，通常认为是可迭代对象私有的实现细节。

任何定义了`iterate`函数的对象都是可迭代的，并且用在用于【[许多依赖迭代的函数](../基础/集合和数据结构.md "Base : Collections and Data Structures")】中。
自下述语法之后，还可直接用在`for`循环：
```
for i in iter
    # 循环体
end
```
翻译为：
```
next = iterate(iter)
while next != nothing
    (i, state) = next
    # 循环体
    next = iterate(iter, state)
end
```
一个简单的例子是定义了长度的平方数可迭代序列：
```
julia> struct Squares
         count::Int
       end

julia> Base.iterate(S::Squares, state=1) = state > S.count ? nothing : (state*state, state+1)
```
只需要带上`iterate`定义，`Squares`类型即已变得优雅强大。
可以如下遍历所有元素：
```
julia> for i in Squares(7)
         println(i)
       end
1
4
9
16
25
36
49
```
可让许多内建方法和可迭代对象一起玩耍，如`in`、`mean`、`std`这等来自`Statistics`标准库模块的：
```
julia> 25 in Squares(9)
true

julia> using Statistics

julia> mean(Squares(99))
3316.6666666666665

julia> std(Squares(99))
2964.596937190619
```
可以再多扩展一些方法给Julia更多有关该迭代集合的信息。
大家知道`Squares`序列中的元素将总是`Int`。
通过扩展`eltype`方法，可提供信息给Julia助其再更复杂的方法中创造更合适的代码。
大家还知道序列中元素的个数，也可以扩展`length`方法：
```
julia> Base.eltype(::Type{Squares}) = Int

julia> Base.length(S::Squares) = S.count
```
现在，当要求Julia收集（`collect`）所有元素到一个数组，Julia可预分配正确尺寸的`Vector{Int}`，而不是盲目地添加（`push!`）每个元素到`Vector{Any}`中。
```
julia> collect(Squares(7))
7-element Array{Int64,1}:
  1
  4
  9
 16
 25
 36
 49
```
当能依赖一般实现的时候，知道存在更简单的算法，也可以扩展指定方法。
例如，有个计算序列和的公式，即可重写更具性能的普通迭代版本方法：
```
julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia> sum(Squares(1314))
757112565

julia> sum(Squares(9527))
288280732180
```
贯穿`Julia.Base`这是很常见的模式：必要方法的一小组定义日常使用接口赋能许多奇特的行为。
在某些情况下，类型想要添加额外地特化那些非常行为，当已知在其特定情况下有更高效的算法可用。

允许用`Iterators.reverse(iterator)`逆序遍历集合也有用。
实际上支持逆序迭代，无论怎样，迭代类型`T`需要为`Iterators.Reverse{T}`实现`iterate`函数。
给定`r::Iterators.Reverse{T}`，类型`T`从属的迭代器是`r.itr`。
在上述`Squares`例子中，可实现`Iterators.Reverse{Squares}`方法：
```
julia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state < 1 ? nothing : (state*state, state-1)

julia> collect(Iterators.reverse(Squares(7)))
7-element Array{Int64,1}:
 49
 36
 25
 16
  9
  4
  1
```

# 索引

|要落实的方法|简要说明|
|:---|:---|
|`getindex(X, i)`|`X[i]`，索引访问元素。|
|`setindex!(X, v, i)`|`X[i] = v`，索引赋值元素。|
|`firstindex(X)`|首个元素。|
|`lastindex(X)`|末尾元素，用于`X[end]`。|

对于上述`Squares`可迭代类型，可以很容易地计算第`i`个元素的平方数。
可以暴露该功能为`S[i]`表达式。
通向该行为，`Squares`仅需要定义`getindex`：
```
julia> function Base.getindex(S::Squares, i::Int)
         1 <= i <= S.count || throw(BoundsError(S, i))
         return i*i
       end

julia> Squares(99)[55]
3025
```
此外，支持`S[end]`语法，必须定义`lastindex`来制定最后一个有效的索引。
还推荐定义`firstindex`指定第一个有效的索引：
```
julia> Base.firstindex(S::Squares) = 1

julia> Base.lastindex(S::Squares) = length(S)

julia> Squares(99)[end]
9801
```
注意，尽管上述只定义带一个整数索引的`getindex`。
非`Int`的任何索引将爆出`MethodError`喊冤没有匹配的方法。
为了支持区间或`Int`向量索引，还得定义别的方法：
```
julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia> Base.getindex(S::Squares, I) = [S[i] for i in I]

julia> Squares(9)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25

julia> typeof(4.)
Float64
```
虽然开始支持更多【[某些内建类型支持的索引操作](./多维数组.md "Multi-dimensional Arrays")】，仍然确实一批行为。
随着添加行为，序列`Squares`看起来越来越像向量。
可以官方地定义`Squares`为`AbstractArray`子类型，而不是自行定义所有行为。

# 抽象数组

|要落实的方法|简要说明|
|:---|:---|
|`size(A)`|返回包含`A`个维度尺寸的元组。|
|`getindex(A, i::Int)`|若`IndexLinear`则线性标量索引。|
|`getindex(A, I:Vararg{Int, N})`|若`IndexCartesian`且`N = ndims(A)`则N维标量索引。|
|`setindex!(A, v, i::Int)`|若`IndexLinear`则标量索引赋值。|
|`setindex!(A, v, I::Vararg{Int, N})`|若`IndexCartesian`且`N = ndims(A)`则N维标量索引赋值。|

|可选方法|默认定义|简要说明|
|:---|:---|:---|
|`IndexStyle(::Type)`|`IndexCartesian()`|返回`IndexLinear`或`IndexCartesian()`，详见下面描述。|
|`getindex(A, I...)`|按照标量`getindex`定义|【[多维且非标量索引](./多维数组.md "Multi-dimensional Arrays")】|
|`setindex!(A, I...)`|按照标量`setindex!`定义|【[多维且非标量索引赋值](./多维数组.md "Multi-dimensional Arrays")】|
|`iterate`|按照标量`getindex`定义|迭代。|
|`length(A)`|`prod(size(A))`|元素个数。|
|`similar(A)`|`similar(A, eltype(A), size(A))`|返回拥有相同形状和元素类型的可变数组。|
|`similar(A, ::Type{S})`|`similar(A, S, size(A))`|返回相同形状和指定元素类型的可变数组。|
|`similar(A, dims::NTuple{Int})`|`similar(A, eltype(A), dims)`|返回相同元素类型和维度尺寸的可变数组。|
|`similar(A, ::Type{S}, dims::NTuple{Int})`|`Array{S}(undef, dims)`|返回指定元素类型和维度尺寸的可变数组。|

|非传统索引|默认定义|简要说明|
|:---|:---|:---|
|`axes(A)`|`map(OneTo, size(A))`|返回有效索引的`AbstractUnitRange`。|
||||