构造函数就是创建新对象的函数，特别是【[复合类型](./类型.md "Types")】实例。
在Julia中，类型对象也可作构造函数：当按照函数调用那样应用参数，创建新的自身类型实例。
之前在介绍复合类型时已经大量提及。例如：
```
julia> struct Fuck
         alice
         bob
       end

julia> fuck = Fuck("qiuxiang", "huaan")
Fuck("qiuxiang", "huaan")

julia> fuck.alice
"qiuxiang"

julia> fuck.bob
"huaan"
```
对很多类型来说，形成新的对象，无外乎将字段值绑定在一起。
然而，创建复合对象，需要更多功能。
有些时候，不变量必须强制执行，要么检查参数、要么转换参数。
[递归数据结构](https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29)，特别是需要引用自身的，
通常在未完成状态下，*不借助首先创建的、不能清晰构建*，并且随后程序化改变即成整体，是不同于对象创建的步骤。
有些时候，构造带少数不同参数的对象比有字段的便捷些。
Julia的对象构造系统处理的不止于此。

术语（nomenclature）：因为构造函数一说参考全部构造某种类型对象的函数，轻微地滥用术语并引用特定构造方法为构造函数是稀松平常的。
在这种情况下，一般明确表达“构造方法”概念而不是“构造函数”术语，特别是经常用在将所有别的方法和特殊的构造方法区分开上。

# 外部构造方法

构造方法仅如Julia中别的函数一样，它的全部即是方法绑定的行为。
相应地，可以简单定义新的方法给构造函数添加功能。
例如，为`Fuck`对象添加只接受一个参数、参数值传递给`alice`和`bob`字段的构造方法（自操）。看代码：
```
julia> Fuck(who) = Fuck(who, who)
Fuck

julia> selfuck = Fuck("cto", "cto")
Fuck("cto", "cto")
```
可以添加无参数的`Fuck`构造方法（空操），为`alice`和`bob`提供了默认值。
```
julia> Fuck() = Fuck("hr")
Fuck

julia> Fuck()
Fuck("hr", "hr")
```
空操屌自操。
依次屌自动提供的双参数构造方法。
种种原因以至清晰简短，额外的构造方法如正常方法一样声明，称作“外部构造方法”。
外部构造方法仅可通过调用别的构造方法来创建新实例，例如自动提供的默认构造方法。

# 内部构造方法

虽然外部构造方法在处理提供额外便捷构造对象的方法问题上大获全胜，但在处理本文提到的另外两种情况下一败涂地：
强制不变量、允许构建自引用的对象。
针对这些问题，需要内部构造方法。
内部构造方法和外部构造方法很像，但有两点不同：

- 在类型声明内声明，而不是像正常方法那样在类型声明外声明。
- 可访问本地已有特殊函数`new`来创建块类型的对象。

举个栗子，假定声明持有一对实数的类型，受“第一个数不能大于第二个数”的限制。
可如下撸码：
```
julia> struct OrderedPair
         prefix::Real
         postfix::Real
         OrderedPair(prefix, postfix) = prefix > postfix ? error("out of order") : new(prefix, postfix)
       end
```
现在`OrderedPair`对象只能以`prefix <= postfix`构造：
```
julia> OrderedPair(0, 1)
OrderedPair(0, 1)

julia> OrderedPair(9527, 1314)
ERROR: out of order
Stacktrace:
 [1] error(::String) at .\error.jl:33
 [2] OrderedPair(::Int64, ::Int64) at .\REPL[9]:4
 [3] top-level scope at none:0
```
如果类型声明`mutable`则进而直接修改字段值更改该不变量，但对象内部未邀请的混乱被认为是垃圾形式。
可在之后任意位置提供额外的外部构造方法，但类型一经声明，没有添加别的内部构造方法的门儿。
由于外部构造方法只能通过调用别的构造方法来创建对象，最终，某些内部构造方法必被调用来创建实例。
这保证所有已声明的类型之对象必须经调用类型提供的某个内部构造方法而存在，从而提供某种程度的类型不变性强制实行。

如果任何内部构造方法已被定义，却没有提供默认构造方法：假定已经备好所需的一切内部构造方法。
默认构造方法和编写带全部对象字段为参数的内部构造方法等价，当然必须是正确的类型，如果对应的字段有类型限制的话，并将这些参数传递给`new`函数，得到新实例结果。
```
julia> struct Kiss
         qiuxiang
         huaan
         Kiss(qx, ha) = new(qx, ha)
       end
```
如此声明和前边的`Fuck`不带显式默认构造方法效果一样。
下述两个类型等价，一个是自动默认构造方法（隐式）、一个是显式默认构造方法。
```
julia> struct T
         t::Int
       end

julia> struct TT
         t::Int
         TT(t) = new(t)
       end

julia> T == TT
false

julia> t = T(9527)
T(9527)

julia> tt = TT(9527)
TT(9527)

julia> t == tt
false
```
*搞清楚，是等价类型，不是相同类型。*
尽可能提供少地提供内部构造方法被认为是好的形式：仅这些内部构造方法显式处理所有参数并强制检查基本错误及转换。
别的便捷构造方法，提供默认值或辅助转换，应当以外部构造方法提供，继而调用内部构造方法处理繁重事务。
这种隔离是（典型地）十分自然。

# 不完全初始化
