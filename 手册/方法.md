回想【[函数](./函数.md "Functions")】，一组值到一个返回值的映射，或抛出异常，如果不能返回合适的值。
相同概念函数或操作对不同参数类型有完全不同的实现是很平常的：两个整数相加和两个浮点数相加是大不一样的，两者的区别就是整型和浮点型参数。
尽管实现不同，这些操作总归是“加”这个公共概念。
相应地，在Julia中，这些行为都取决于一个对象：`+`函数。

为了帮助骚年流畅地应用相同概念的众多不同实现，函数绝不须一次定义，而能分段提供确定参数类型和参数个数组合指定行为地定义。
函数的一个可能行为的定义称为方法。
迄今为止，大家仅演练了只定义了一个方法的函数样例，适用全部类型参数。
然而，方法定义的鲜明特征可注解地表明参数类型及参数个数，并非单个方法定义能提供的。
当函数适合特定参数组，最适合某参数组的方法被应用。
因此，函数的全部行为是其各种各样的方法定义的行为的平凑物。
如果这个拼凑物设计得好，即使各个方法得每个实现可能完全不同，函数外在得表现是无痕并一致的。

应用一个函数是选择执行哪个方法叫做分发（重载）。
Julia允许基于参数个数、参数类型地选择最合适的方法。
这跟传统面向对象编程语言不同——这些货只是基于第一个参数分发，通常有特殊参数语法，甚至隐含的而不是明确地写出参数。

    在C++或Java中，例如，调用`object.method(argumentAlice, argumentBob)`，`object`接收方法调用并隐含地传递给方法，通过`this`关键字，而不是某个显式的方法参数。当前`this`是方法调用的接收者，它可以一并省略，只写`method(argumentAlice, argumentBob)`，此时`this`暗指接收对象。

根据函数全体参数决定应该调用哪个方法，而不是第一个参数，人称【[多重分发](https://en.wikipedia.org/wiki/Multiple_dispatch)】。
多重分发在数学编码中非常有用，在该场合人工认为操作属于某个参数而不属于别的任何参数毫无意义：例如加法操作，`x+y`中`+`属于`x`还是属于`y`？
数学操作的实现通常基于全体参数的类型。
甚至超出（抛开）数学操作，不管怎样，多重分发都是（end up）构造和组织程序的强大且便捷的范式。

# 定义方法

直到现在，咱曾经在咱的例程中，仅定义过只有一个参数不受约束的方法的函数。
这些函数行为就像在传统动态类型编程语言中一样。
不过，咱几乎可以继续撸多重分发和方法而不用搭理这回事：所有Julia标准函数和操作，像前述的`+`函数，有众多方法定义，在各种参数类型和个数的组合上各显神通。

定义一个函数时，可选择地约束适用的参数类型，用`::`类型断言操作，在【[复合类型](./类型.md "Types - Composite Types")】介绍的：
```
julia> f(x::Float64, y::Float64) = 3x + 4y
f (generic function with 1 method)
```
该函数定义仅适合`x`和`y`都是`Float64`类型的值：
```
julia> f(3.0, 4.0)
25.0
```
任何一个不是`Float64`的参数调用都会报`MethodError`：
```
julia> f(9527, 4.0)
ERROR: MethodError: no method matching f(::Int64, ::Float64)
Closest candidates are:
  f(::Float64, ::Float64) at REPL[1]:1
Stacktrace:
 [1] top-level scope at none:0

julia> f(3.0, 1314)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, ::Float64) at REPL[1]:1
Stacktrace:
 [1] top-level scope at none:0

julia> f(Float32(3.0), Float32(4.0))
ERROR: MethodError: no method matching f(::Float32, ::Float32)
Stacktrace:
 [1] top-level scope at none:0

julia> f("3.0", "4.0")
ERROR: MethodError: no method matching f(::String, ::String)
Stacktrace:
 [1] top-level scope at none:0
```
正如卿所见，参数必须是精确的`Float64`类型。
别的数值类型，如`Float32`和`Int`值，不能自动转换成`Float64`，或字符串（字面值）解析为数字。
因为`Float64`是具体类型，Julia中具体类型不能有子类型，这么定义`f`只适用于`Float64`类型的参数。
然而编写参数是抽象类型的通用方法经常会有用：
```
julia> f(x::Number, y::Number) = 3.0x - 4.0y
f (generic function with 2 methods)

julia> f(9527, 1314)
23325.0
```
该方法定义适用任意一组`Number`实例的参数。
不需要是相同类型的，各自可选数值类型。
处理各个数值类型的问题委派给表达式`3.0x - 4.0y`的算术操作。

定义多个方法的函数，有朋友简单地以不同参数类型和参数个数多次定义函数。
第一个方法定义为创建该函数对象的函数，之后的方法定义为给该函数对象添加新方法的函数。
当应用该函数时，参数类型和参数个数最匹配的的指定方法定义将被执行。
因此，上述定义的两个方法，强调（重点——敲黑板），定义了所有抽象类型`Number`的各对儿实例为参数的`f`的行为——但和`Float64`类型对儿指定的行为不同。
如果其中一个参数是`Float64`但另外一个不是，则不调用`f(x::Float64, y::Float64)`，而调用更一般的`f(x::Number, y::Number)`方法：
```
julia> f(2.0, 2.0)
14.0

julia> f(2, 2)
-2.0

julia> f(1+1im, 1+1im)
-1.0 - 1.0im
```
那个`3x - 4y`仅用于`f(2.0, 2.0)`的情况，但`3.0x - 4.0y`则用于其余场景。
函数参数未执行任何强制转换或提升转换：Julia中所有提升转换都是显式的，而非魔术般。
【[转换和提升](./转换和提升.md "Conversion and Promotion")】，无论如何，展示[足够高级的技术和魔法难以区分的应用有多聪明](https://en.wikipedia.org/wiki/Arthur_C._Clarke "C Clarke - British Science Fiction Writer")。

对于非数值或更少更多参数，函数`f`保留未定义，调用的话仍然报`MethodError`错误：
```
julia> f(2)
ERROR: MethodError: no method matching f(::Int64)
Closest candidates are:
  f(::Number, ::Number) at REPL[10]:1
  f(::Float64, ::Float64) at REPL[1]:1
Stacktrace:
 [1] top-level scope at none:0

julia> f("huaan", "qiuxiang")
ERROR: MethodError: no method matching f(::String, ::String)
Stacktrace:
 [1] top-level scope at none:0

julia> f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(::Float64, ::Float64) at REPL[1]:1
  f(::Number, ::Number) at REPL[10]:1
Stacktrace:
 [1] top-level scope at none:0

julia> f(2, 250, 9527, 1314)
ERROR: MethodError: no method matching f(::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  f(::Number, ::Number) at REPL[10]:1
Stacktrace:
 [1] top-level scope at none:0
```
在交互式会话中，很容易了解函数对象自身存在多少方法：
```
julia> f
f (generic function with 2 methods)
```
该输出告诉咱`f`是有两个方法的函数。
想找出这些方法的签名，用`methods`函数：
```
julia> methods(f)
# 2 methods for generic function "f":
[1] f(x::Float64, y::Float64) in Main at REPL[1]:1
[2] f(x::Number, y::Number) in Main at REPL[10]:1
```
展示了这两个方法的具体模式：一个带两个`Float64`参数、一个带两个`Number`参数。
同时也表明各个方法定义所在的文件及其行号：因为这些方法在JuliaREPL中定义，得到的表面上行号是`REPL[n]:1`。
